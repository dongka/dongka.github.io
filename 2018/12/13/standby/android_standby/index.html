<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="standby linux," />










<meta name="description" content="安卓电源状态首先安卓将电源分为以下几种情况： 1.sleep：休眠 从代码看，安卓将系统的休眠原因分为以下几种： goToSleepNoUpdateLocked     GO_TO_SLEEP_REASON_DEVICE_ADMIN//Going to sleep due to device administration policy      GO_TO_SLEEP_REASON_TIMEOUT">
<meta name="keywords" content="standby linux">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓休眠流程">
<meta property="og:url" content="http://yoursite.com/2018/12/13/standby/android_standby/index.html">
<meta property="og:site_name" content="知识总结">
<meta property="og:description" content="安卓电源状态首先安卓将电源分为以下几种情况： 1.sleep：休眠 从代码看，安卓将系统的休眠原因分为以下几种： goToSleepNoUpdateLocked     GO_TO_SLEEP_REASON_DEVICE_ADMIN//Going to sleep due to device administration policy      GO_TO_SLEEP_REASON_TIMEOUT">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2020-04-20T13:01:01.054Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓休眠流程">
<meta name="twitter:description" content="安卓电源状态首先安卓将电源分为以下几种情况： 1.sleep：休眠 从代码看，安卓将系统的休眠原因分为以下几种： goToSleepNoUpdateLocked     GO_TO_SLEEP_REASON_DEVICE_ADMIN//Going to sleep due to device administration policy      GO_TO_SLEEP_REASON_TIMEOUT">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/13/standby/android_standby/"/>





  <title>安卓休眠流程 | 知识总结</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">知识总结</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/standby/android_standby/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">安卓休眠流程</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T00:07:09+00:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/standby/" itemprop="url" rel="index">
                    <span itemprop="name">standby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1><span id="安卓电源状态">安卓电源状态</span></h1><p>首先安卓将电源分为以下几种情况：</p>
<p><strong>1.sleep：</strong>休眠</p>
<pre><code>从代码看，安卓将系统的休眠原因分为以下几种：
goToSleepNoUpdateLocked
    GO_TO_SLEEP_REASON_DEVICE_ADMIN//Going to sleep due to device administration policy 
    GO_TO_SLEEP_REASON_TIMEOUT //Going to sleep due to screen timeout
    GO_TO_SLEEP_REASON_LID_SWITCH //Going to sleep due to lid switch 滑盖
    GO_TO_SLEEP_REASON_POWER_BUTTON //Going to sleep due to power button
    GO_TO_SLEEP_REASON_SLEEP_BUTTON //Going to sleep due to sleep button 头显的远近
    GO_TO_SLEEP_REASON_HDMI //Going to sleep due to HDMI standby
    GO_TO_SLEEP_REASON_ACCESSIBILITY//Going to sleep by an accessibility service request
    如果不是以上几种情况，则默认为应用导致的休眠：
    GO_TO_SLEEP_REASON_APPLICATION//Going to sleep by application request
</code></pre><p><strong>2.nap：</strong>进入屏保</p>
<pre><code>默认屏幕超时后进入休眠，如果希望进入的是屏保模式
则需要在overlay/frameworks/base/core/res/res/values/config.xml中将屏保模式打开
&lt;bool name=&quot;config_dreamsActivatedOnSleepByDefault&quot;&gt;true&lt;/bool&gt;    
</code></pre><p><strong>3.wakeup：</strong>唤醒</p>
<pre><code>wakeUpNoUpdateLocked
从以下状态中唤醒,reason不固定：
    WAKEFULNESS_ASLEEP:
    WAKEFULNESS_DREAMING：
    WAKEFULNESS_DOZING：
</code></pre><p><strong>4.shutdown：</strong>关机<br><strong>5.reboot：</strong>重启  </p>
<p>在此前的内核篇，我们讲到了用户层会去轮询查看是否有唤醒事件需要处理，如果没有则echo mem &gt; /sys/power/state,从而进入内核的休眠唤醒流程；所以在本篇我们主要将这两个流程是怎么衔接上的~</p>
<p><strong>由于通过调用api进行休眠唤醒的流程更为简单，所以我们看下老化apk是如何进行调用休眠唤醒的api，然后进行老化休眠唤醒实验的；</strong></p>
<h1><span id="老化休眠唤醒代码demo">老化休眠唤醒代码demo</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">休眠动作：</span><br><span class="line">单点击开始后，设置闹钟和走休眠流程： </span><br><span class="line">runSleepWakeUpTest()</span><br><span class="line">	mAlarmMgr.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() </span><br><span class="line">												+ (mSleepTime * 1000),</span><br><span class="line">												pendIntent);</span><br><span class="line"></span><br><span class="line">	standby();</span><br><span class="line">		pm.goToSleep(SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">唤醒动作：</span><br><span class="line"> onReceive</span><br><span class="line">	  </span><br><span class="line">	PowerManager pm = (PowerManager) this</span><br><span class="line">			   .getSystemService(Context.POWER_SERVICE);</span><br><span class="line">	if (getAndroidSDKVersion() &gt;= 17) &#123;</span><br><span class="line">	      pm.wakeUp(SystemClock.uptimeMillis());</span><br><span class="line">	</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		   pm.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从调用流程可以看到就是不断的调用goToSleep,然后设置一个闹钟，当闹钟来临的时候唤醒系统;</p>
<p><strong>framework相关代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">core/java/android/os/PowerManager.java</span><br><span class="line">public void goToSleep(long time) &#123;</span><br><span class="line">    	goToSleep(time, GO_TO_SLEEP_REASON_APPLICATION, 0);    </span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">./services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line">public void goToSleep(long eventTime, int reason, int flags) &#123;</span><br><span class="line">    if (eventTime &gt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;event time must not be in the future&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	goToSleepInternal(eventTime, reason, flags, uid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void goToSleepInternal(long eventTime, int reason, int flags, int uid) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (goToSleepNoUpdateLocked(eventTime, reason, flags, uid)) &#123;</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="sleep流程">sleep流程</span></h1><p>当屏幕超时，按power键休眠，和应用主动调goToSleep；无论是哪种方式，如果系统启动没有异常，都会走到PowerManagerService的核心函数，<strong>updatePowerStateLocked</strong>；按照安卓注释，将updatePowerStateLocked 分为五个阶段，我们也按照五个阶段对该函数的功能进行讲解；</p>
<p><strong>Phase 0: Basic state updates</strong></p>
<pre><code>1.USB插播亮屏入口点
 //如果需要插拔事件不影响到屏幕的亮灭，在overlay/frameworks/base/core/res/res/values/config.xml下
 //修改&lt;bool name=&quot;config_unplugTurnsOnScreen&quot;&gt;true&lt;/bool&gt;从字面意思貌似是拔出的时候不亮屏；
 //mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(                                                                                                                                               
            com.android.internal.R.bool.config_unplugTurnsOnScreen);//从这里就能完整看到这个配置的用途，插拔都会影响到屏幕

2.更新低电量模式        
当电池电量状态发生变化的时候，才能调到该方法
updateIsPoweredLocked(mDirty);

判断系统是否在setting中设置了充电时保持屏幕亮屏
updateStayOnLocked(mDirty);

updateScreenBrightnessBoostLocked(mDirty);  
</code></pre><p><strong>Phase 1: Update wakefulness</strong></p>
<p>wakefulness,安卓将休眠唤醒的电源状态分为四个：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>状态介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>WAKEFULNESS_ASLEEP</td>
<td>设备处于sleep状态，只能被wakeUp函数唤醒，屏幕会被关闭，设备先进入doze状态</td>
</tr>
<tr>
<td>WAKEFULNESS_AWAKE</td>
<td>设备处于awake状态，可通过goToSleep的接口将设备置于休眠状态，当用户超时时间到了设备将开始dreaming或者进入休眠流程  </td>
</tr>
<tr>
<td>WAKEFULNESS_DREAMING</td>
<td>设备处于dreaming状态，会被wakeUp唤醒，当dreaming时间结束或者</td>
</tr>
<tr>
<td>WAKEFULNESS_DOZING</td>
<td>打盹</td>
</tr>
</tbody>
</table>
<pre><code>// Loop because the wake lock and user activity computations are influenced
// by changes in wakefulness. 
//此循环只会循环两次，然后就退出；
for (;;) {
    updateWakeLockSummaryLocked(dirtyPhase1);
        getWakeLockSummaryFlags(wakeLock);
        adjustWakeLockSummaryLocked(mWakeLockSummary);
    updateUserActivitySummaryLocked(now, dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
                 break;  
     }           
 }
</code></pre><p>1.<strong>updateWakeLockSummaryLocked(dirtyPhase1);</strong> ；</p>
<p><strong>简单先介绍安卓的锁：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>属性</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>WAKE_LOCK_CPU</td>
<td>保持CPU运行，屏幕和键盘灯允许关闭。用户按power键之后，屏幕和键盘灯会关闭，CPU keep on，直到所有该类型所被释放</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT  WAKE_LOCK_BUTTON_BRIGH</td>
<td>保证屏幕和键盘灯亮（at full brightness）。用户按power键之后，CPU和屏幕键盘灯都会被关闭</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT</td>
<td>保证屏幕亮（full brightness），键盘灯允许关闭。用户按power键之后，CPU和屏幕都会被关闭</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT</td>
<td>保证屏幕亮（full brightness），键盘灯允许关闭。用户按power键之后，CPU和屏幕都会被关闭</td>
</tr>
<tr>
<td>PROXIMITY_SCREEN_OFF</td>
<td>PROXIMITY_SCREEN_OFF</td>
<td>pSensor导致的灭屏情况下系统不会进入休眠，正常情况下不影响系统休眠</td>
</tr>
<tr>
<td>DOZE_WAKE_LOCK</td>
<td>WAKE_LOCK_DOZE</td>
<td>使屏幕进入low power状态，允许cpu挂起。只有在电源管理进入doze模式时生效</td>
</tr>
<tr>
<td>DRAW_WAKE_LOCK</td>
<td>WAKE_LOCK_DRAW</td>
<td>保持设备awake状态已完成绘制事件，只在doze模式下生效</td>
</tr>
</tbody>
</table>
<p>该函数的主要作用为，遍历申请的所有锁，根据当前mWakefulness的状态(asleep,dozing,wake，dream)，过滤不需要的锁,如DOZE模式下过滤<strong>WAKE_LOCK_SCREEN_BRIGHT</strong>，<strong>WAKE_LOCK_SCREEN_DIM</strong>，<strong>WAKE_LOCK_BUTTON_BRIGHT</strong>，而ASLEEP模式下在基础上过滤<strong>WAKE_LOCK_PROXIMITY_SCREEN_OFF</strong>,在Dream模式下会添加<strong>WAKE_LOCK_CPU</strong>.</p>
<p>2.<strong>updateUserActivitySummaryLocked(now, dirtyPhase1);</strong></p>
<p>mUserActivitySummary的种类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类型介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER_ACTIVITY_SCREEN_BRIGHT</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>USER_ACTIVITY_SCREEN_DIM</td>
<td>屏幕变暗</td>
</tr>
<tr>
<td>USER_ACTIVITY_SCREEN_DREAM</td>
<td>屏保模式</td>
</tr>
</tbody>
</table>
<pre><code>这里有三个时间参数：
sleepTimeout:设备完全休眠的时间，该值可以理解为保持唤醒或屏保的最大值或者上限，并且该值要大 
             Settings.System.SCREEN_OFF_TIMEOUT,默认为-1；表示禁用此功能项；
screenOffTimeoutSetting:表示设备在一段不活动进入睡眠或者屏保的时间，也称为用户超时时间，但屏幕不一定关闭，可能进入屏保
screenDimDuration 亮屏后不操作，多久变暗；
根据这三个时间参数计算nextTimeout的时间：
         scheduleUserInactivityTimeout(nextTimeout);
</code></pre><p>故该函数的主要作用为，更新用户活动时间，当设备和用户有交互的时，都会根据当前时间和休眠时长，dim时长，所处状态而计算下次休眠的时间，从而完成活动超时时的操作，如由亮屏进入Dim的时长，Dim到灭屏的时长，亮屏到屏保的时长；</p>
<p>3.<strong>updateWakefulnessLocked</strong></p>
<pre><code>if (shouldNapAtBedTimeLocked()) {                                            
changed = napNoUpdateLocked(time, Process.SYSTEM_UID);
    --&gt;mSandmanSummoned = true;
       setWakefulnessLocked(WAKEFULNESS_DREAMING, 0);
       --&gt;mNotifier.onWakefulnessChangeStarted(wakefulness, reason);                     
 } else {                                                                      
changed = goToSleepNoUpdateLocked(time,                                   
        PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, 0, Process.SYSTEM_UID);  
       --&gt; mSandmanSummoned = true;
           setWakefulnessLocked(WAKEFULNESS_DOZING, reason);
           --&gt;mNotifier.onWakefulnessChangeStarted(wakefulness, reason); 

 }                                                                             
</code></pre><p>该函数的主要作用在与更新电源状态；</p>
<p><strong>Phase2:Lock profiles that became inactive/not kept awake.</strong></p>
<pre><code>updateProfilesLocked(now); //估计是cts的时候使用，这个不再赘述
</code></pre><p><strong>Phase 3: Update display power state.</strong></p>
<pre><code>updateDisplayPowerStateLocked(dirtyPhase2); 
--&gt;mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked(); 
--&gt;requestPowerState
    --&gt;return mDisplayPowerController.requestPowerState(request,waitForNegativeProximity);
        --&gt;requestPowerState
            --&gt;sendUpdatePowerStateLocked
                --&gt;Message msg = mHandler.obtainMessage(MSG_UPDATE_POWER_STATE);
                    mHandler.sendMessage(msg);
handleMessage(Message msg)
   --&gt;updatePowerState();
      --&gt;animateScreenStateChange
        --&gt;setScreenState
        --&gt;mPowerState.setScreenState(state);(DPC)
            --&gt;scheduleScreenUpdate--&gt;postScreenUpdateThreadSafe--&gt;setState-&gt;mLock.notifyAll
                --&gt;mBlanker.requestDisplayState(DPS)
            --&gt;callbacks.onDisplayStateChange(state)  --&gt;根据亮灭屏走PowerManagerService enable/disable autosuspend
            --&gt;requestGlobalDisplayStateInternal(state, brightness=0) --&gt;mTempDisplayStateWorkQueue.get(i).run()(DMS)
            --&gt;SurfaceControl.setDisplayPowerMode(LDA)

        --&gt;blockScreenOn 在亮屏的流程里面监听窗口是否绘制完成，
           是的话重新发起updatePowerState,设置mColorFadeLevel为1；此时才会去设置背光，这时候对于用户来说屏幕才是最终的亮了
           否的话此时的背光值一直会为0；


        --&gt;mWindowManagerPolicy.screenTurningOff(mPendingScreenOffUnblocker)
        在灭屏的同时还发起了activity的pause流程
        --&gt;updateScreenOffSleepToken
        --&gt;acquireSleepToken
        --&gt;updateSleepIfNeededLocked
        --&gt;goingToSleepLocked
        --&gt;checkReadyForSleepLocked
        --&gt;putStacksToSleepLocked
        --&gt;goToSleepIfPossible
        --&gt;startPausingLocked
        --&gt;schedulePauseAcvity --&gt; sendMessage
        --&gt;handleMessage --&gt;handlePauseActivity--&gt;performPauseActivity--&gt;performPauseActivityIfNeed
        --&gt;callActivityOnPause --&gt;activity.performPause--&gt; onPause
        唤醒的时候应用resume的流程
        ActivityStackSupervisor.java
        SleepTokenImpl.release
        --&gt;removeSleepTokenLocked
        --&gt;updateSleepIfNeededLocked
        --&gt;applySleepTokensLocked
        --&gt;resumeFocusedStackTopActivityLockedi
        --&gt;resumeTopActivityUncheckedLocked
        --&gt;resumeTopActivityInnerLocked
</code></pre><p>函数作用：决策屏幕的量灭状态</p>
<pre><code>如果当前是WAKEFULNESS_ASLEEP状态，直接设置屏幕为POLICY_OFF

如果包含以下一种状态，就设置屏幕为POLICY_BRIGHT

1.mWakeLockSummary 如果有 WAKE_LOCK_SCREEN_BRIGHT类型的wakeLock 

2.mUserActivitySummary 屏幕状态为USER_ACTIVITY_SCREEN_BRIGHT

3.当前系统未启动完成

4.当前处于最大屏幕亮度

可以看出屏幕的状态和前面设置的wakeLock，stayon,userActivity，screenBrightness等有关
</code></pre><p><strong>Phase 4: Update dream state (depends on display ready signal).</strong>        </p>
<pre><code>updateDreamLocked(dirtyPhase2, displayBecameReady);
--&gt;scheduleSandmanLocked();
    --&gt;if (!mSandmanScheduled) {
         Message msg = mHandler.obtainMessage(MSG_SANDMAN);
      }
</code></pre><p>函数作用：决定是否进入屏保状态</p>
<p><strong>Phase 5: Send notifications, if needed.</strong></p>
<pre><code>finishWakefulnessChangeIfNeededLocked();
</code></pre><p>函数作用：发出wakefulness发生改变的通知</p>
<p><strong>Phase 6: Update suspend blocker.</strong></p>
<pre><code>// Because we might release the last suspend blocker here, we need to make sure
// we finished everything else first!  
updateSuspendBlockerLocked(); 
    --&gt;needWakeLockSuspendBlocker = ((mWakeLockSummary &amp; WAKE_LOCK_CPU) != 0);//根据是否有CPU的wakelock，来决定cpu是否保持唤醒
    --&gt;needDisplaySuspendBlockerLocked//根据前面屏幕的状态，屏幕是否需要亮屏，来决定是否需要持持有屏幕的锁             
</code></pre><p>函数作用：进行锁的申请和释放</p>
<p>分析完整个函数的调用流程，依然找不到怎么跟内核休眠的流程衔接起来；那么安卓是什么是否才会去调用内核休眠流程对接起来的？原来安卓在上面的函数调到灭屏的接口时候，才会去使能autosuspend的流程；想想也没有什么毛病，毕竟对于用户来说灭屏时标识着系统要走到休眠的标志；</p>
<p>代码流程如下：</p>
<pre><code>onDisplayStateChange
--&gt;if (state == Display.STATE_OFF) {
    if (!mDecoupleHalAutoSuspendModeFromDisplayConfig) {
           setHalInteractiveModeLocked(true);
    }
    }
 nativeSetAutoSuspend(enable);
    enabelAutosuspend
        suspendControl-&gt;enableAutoSuspend 使能autoSuspend进程，进程会一直检测系统是否无锁
        gSuspendBlocker-&gt;release释放锁
对应的灭屏disable的流程
    disableAutoSuspend
    suspendHal-&gt;acquireWakeLock(WakeLockType:PARTIAL,&quot;PowerManager.SuspendLockout&quot;);所以一旦亮屏我们都会在内核的wake_lock节点看到这个锁,当然等到安卓把这个锁放在上层申请
    的话就看不到了 
</code></pre><p>为了呼应上次内核篇上讲的安卓等待的时机，我们在这里把读写wakeup count内核的的相关操作也po出来；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ReadFdToString(wakeup_count_fd, &amp;wakeup_count)</span><br><span class="line">	bool pm_get_wakeup_count(unsigned int *count, bool block)    </span><br><span class="line">	&#123;                                                            </span><br><span class="line">	    unsigned int cnt, inpr;                                  </span><br><span class="line">	                                                             </span><br><span class="line">	    if (block) &#123;                                             </span><br><span class="line">	        DEFINE_WAIT(wait);                                   </span><br><span class="line">	                                                             </span><br><span class="line">	        for (;;) &#123;                                           </span><br><span class="line">	            prepare_to_wait(&amp;wakeup_count_wait_queue, &amp;wait, </span><br><span class="line">	                    TASK_INTERRUPTIBLE);                     </span><br><span class="line">	            split_counters(&amp;cnt, &amp;inpr);                     </span><br><span class="line">	            if (inpr == 0 || signal_pending(current))        </span><br><span class="line">	                break;                                       </span><br><span class="line">	                                                             </span><br><span class="line">	            schedule();                                      </span><br><span class="line">	        &#125;                                                    </span><br><span class="line">	        finish_wait(&amp;wakeup_count_wait_queue, &amp;wait);        </span><br><span class="line">	    &#125;                                                        </span><br><span class="line">	                                                             </span><br><span class="line">	    split_counters(&amp;cnt, &amp;inpr);                             </span><br><span class="line">	    *count = cnt;                                            </span><br><span class="line">	    return !inpr;                                            </span><br><span class="line">	&#125;</span><br><span class="line">可以看到在读函数里面也会去判断是否有唤醒事件在处理，如果有唤醒事件那么就会不断的阻塞在获取进程当中；</span><br><span class="line"></span><br><span class="line">WriteStringToFd(wakeup_count, wakeup_count_fd)</span><br><span class="line">	bool pm_save_wakeup_count(unsigned int count)     </span><br><span class="line">	&#123;                                                 </span><br><span class="line">	    unsigned int cnt, inpr;                       </span><br><span class="line">	    unsigned long flags;                          </span><br><span class="line">	                                                  </span><br><span class="line">	    events_check_enabled = false;                 </span><br><span class="line">	    spin_lock_irqsave(&amp;events_lock, flags);       </span><br><span class="line">	    split_counters(&amp;cnt, &amp;inpr);                  </span><br><span class="line">	    if (cnt == count &amp;&amp; inpr == 0) &#123;              </span><br><span class="line">	        saved_count = count;                      </span><br><span class="line">	        events_check_enabled = true;              </span><br><span class="line">	    &#125;                                             </span><br><span class="line">	    spin_unlock_irqrestore(&amp;events_lock, flags);  </span><br><span class="line">	    return events_check_enabled;                  </span><br><span class="line">	&#125;</span><br><span class="line">可以看到在写函数中，呼应到了我们内核篇中，当判断是否save_count == wakeup_count &amp;&amp; inpr==0这两个判断为没有唤醒事件，之后就开始写相关的节点，</span><br><span class="line"></span><br><span class="line">success = WriteStringToFd(sleep_state, state_fd);//echo mem &gt; /sys/power/state 发起内核进入休眠流程；</span><br></pre></td></tr></table></figure>
<p>总之，当安卓灭屏后，才会使能autosuspend不断轮询是否有锁也即唤醒事件，没有才会下发mem到写到内核节点state中；</p>
<h1><span id="安卓的唤醒流程">安卓的唤醒流程</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputManagerService interceptKeyBeforeQueueing</span><br><span class="line">InputMonitor        interceptKeyBeforeQueueing</span><br><span class="line">PhoneWindowManager  interceptKeyBeforeQueueing</span><br><span class="line">		    inputceptPowerKeyDown</span><br><span class="line">		    wakeUpFromPowerKey</span><br><span class="line">		    wakeUp</span><br><span class="line">PowerManager	    wakeUp</span><br><span class="line">PowerManagerService wakeUp</span><br></pre></td></tr></table></figure>
<h1><span id="android-r上的变更">android R上的变更</span></h1><p>androidR上，谷歌说要弃用/sys/power/wake_lock节点；安卓此前申请锁的流程在hardware/libhardware_legacy/power.cpp;原理就是去往wake_lock节点写值;<br>现在的话想将这个流程放在system/hardware/interfaces/suspend中进行实现；</p>
<p>在这里只能说谷歌终于想通了要把这套放在用户层，毕竟曾经为了wake_lock,一直在争吵，最后还是被谷歌给干进内核，现在的话又抽出来放在用户层里面；具体细节可以参照这篇文章<a href="http://www.wowotech.net/pm_subsystem/wakelocks.html" target="_blank" rel="noopener">Linux电源管理</a></p>
<p>谷歌列举这样的好处是：</p>
<ol>
<li>减少对内核的依赖</li>
<li>在没有debugfs的时候用户层仍有能力去debug和log suspend blocks</li>
<li>当进程消亡的时候可以进行锁通过binder的管理进行释放 dangling wake locks</li>
</ol>
<p>通过mSuspendCounter去统计当前持锁的数量，当mSuspendCounter为0的时候，说明上层持锁为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void SystemSuspend::initAutosuspend() &#123;                                                             </span><br><span class="line">    std::thread autosuspendThread([this] &#123;                                                          </span><br><span class="line">        while (true) &#123;                                                                              </span><br><span class="line">            std::this_thread::sleep_for(mSleepTime);   //如果失败了，会更改autosuspend的时间，100ms~1min                                             </span><br><span class="line">            lseek(mWakeupCountFd, 0, SEEK_SET);                                                     </span><br><span class="line">            const string wakeupCount = readFd(mWakeupCountFd);                                      </span><br><span class="line">            if (wakeupCount.empty()) &#123;                                                              </span><br><span class="line">                PLOG(ERROR) &lt;&lt; &quot;error reading from /sys/power/wakeup_count&quot;;                        </span><br><span class="line">                continue;                                                                           </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">                                                                                                    </span><br><span class="line">            auto counterLock = std::unique_lock(mCounterLock);                                      </span><br><span class="line">            mCounterCondVar.wait(counterLock, [this] &#123; return mSuspendCounter == 0; &#125;);//申请锁的时候mSuspendCounter会增加；释放的时候mSuspendCounter会减少            </span><br><span class="line">            // The mutex is locked and *MUST* remain locked until we write to /sys/power/state.     </span><br><span class="line">            // Otherwise, a WakeLock might be acquired after we check mSuspendCounter and before we </span><br><span class="line">            // write to /sys/power/state.                                                           </span><br><span class="line">                                                                                                    </span><br><span class="line">            if (!WriteStringToFd(wakeupCount, mWakeupCountFd)) &#123;                                    </span><br><span class="line">                PLOG(VERBOSE) &lt;&lt; &quot;error writing from /sys/power/wakeup_count&quot;;                      </span><br><span class="line">                continue;                                                                           </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">            bool success = WriteStringToFd(kSleepState, mStateFd);                                  </span><br><span class="line">            counterLock.unlock();                                                                   </span><br><span class="line">                                                                                                    </span><br><span class="line">            if (!success) &#123;                                                                         </span><br><span class="line">                PLOG(VERBOSE) &lt;&lt; &quot;error writing to /sys/power/state&quot;;                               </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">                                                                                                    </span><br><span class="line">            mControlService-&gt;notifyWakeup(success);                                                 </span><br><span class="line">                                                                                                    </span><br><span class="line">            updateSleepTime(success);                                                               </span><br><span class="line">        &#125;                                                                                           </span><br><span class="line">    &#125;);                                                                                             </span><br><span class="line">    autosuspendThread.detach();                                                                     </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;automatic system suspend enabled&quot;;                                                </span><br><span class="line">&#125;</span><br><span class="line">关机充电判断休眠唤醒原理大同小异 </span><br><span class="line">	system/core/libsuspend/autosuspend.c</span><br><span class="line">	int autosuspend_enable(void)</span><br><span class="line">	&#123;</span><br><span class="line">    	autosuspend_init();</span><br><span class="line">			autosuspend_ops = autosuspend_wakeup_count_init(); </span><br><span class="line">    	autosuspend_ops-&gt;enable();   </span><br><span class="line">			autosuspend_wakeup_count_enable（）</span><br><span class="line">	&#125;</span><br><span class="line">	system/core/libsuspend/autosuspend_wakeup_count.cpp</span><br><span class="line">	autosuspend_wakeup_count_enable（）</span><br><span class="line">		autosuspend_init();</span><br><span class="line">			创建一个进程：suspend_thread_func 这个进程主要就是用来做轮询的动作</span><br><span class="line">		sem_post(&amp;suspend_lockout);</span><br><span class="line">	suspend_thread_func</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		 if (!ReadFdToString(wakeup_count_fd, &amp;wakeup_count)) &#123; //读取wakeup count值，如果成功，将读取的值回写，否则说明正在处理wakeup events,continue</span><br><span class="line">			continue; </span><br><span class="line">		 &#125;</span><br><span class="line">		 int ret = sem_wait(&amp;suspend_lockout);//通过信号量来控制这个流程是否要继续走下去，当disable的时候信号量为0，进程会阻塞在这里等待；</span><br><span class="line">		 if (WriteStringToFd(wakeup_count, wakeup_count_fd)) &#123; //回写后，判断返回值是否成功，如果不成功（说明读写过程中产生了wakeup events）,继续读，写，直到成功。成功后，可以触发电源状态切换</span><br><span class="line">			   success = WriteStringToFd(sleep_state, state_fd);                    </span><br><span class="line">		&#125;</span><br><span class="line">		ret = sem_post(&amp;suspend_lockout);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="其他">其他</span></h1><p><strong>如何设置安卓休眠超时时间？</strong></p>
<pre><code>settings get system screen_off_timeout
settings put system screen_off_timeout 2147483647 //设置永不休眠 
</code></pre><p><strong>设置屏保命令</strong><br>    settings put secure screensaver_activate_on_sleep 1 打开屏保<br><strong>设置插入适配器后不休眠</strong><br>    settings put global stay_on_while_plugged_in 1<br><strong>安卓系统不休眠debug </strong></p>
<pre><code>查看上层有没有释放锁
    dumpsys power | grep -Hrsn &apos;LOCK&apos;
PARTIAL_WAKE_LOCK              &apos;messaging_service_start_wakelock&apos; 
查看active_since这一项，看哪个锁不为0
      cat /sys/kernel/debug/wakeup_sources

上层传向底层的锁
cat /sys/power/wake_lock
当这几步查找后都没有对应的锁时，可以通过/sys/power/pm_test结点,操作设备进入对应的休眠阶段，详见linux休眠篇章
</code></pre><p><strong>进入深度休眠后被唤醒问题debug</strong></p>
<pre><code>一般而言，平台会提供深度休眠后如何查看系统唤醒源，如全志平台的查看方式为
    一：休眠的时候不关闭终端
    echo N &gt; /sys/module/printk/parameters/console_suspend
    二：唤醒后查看对应的唤醒源
    查看唤醒时候打印:
        platform wakeup, standby wakesource is:0x10000
    在allwinner对应的pm.h里面就可以看到对应的唤醒源编号，如linux4.9的在driver/soc/sunxi/pm.h 
    其他版本可以直接搜索关键字找到对应的唤醒源编号；
        #define CPUS_WAKEUP_DESCEND     (1&lt;&lt;16)
    而CPUS的GPIO一般是WIFI中断管脚在连接，故此时可以断开wifi连接查看系统唤醒是否依然异常
另外如果当log出现为闹钟唤醒：
    platform wakeup, standby wakesource is:0x100000
    查看对应唤醒源编号
    #define CPUS_WAKEUP_ALM0        (1&lt;&lt;20)
这种情况下我们一般需要通过去查看到底是哪个应用去唤醒系统的：这个时候我们可以借助这个应用 BetterBatteryStats2.0
    1.下载地址：
    http://cn.apkhere.com/app/com.asksven.betterbatterystats
    安装该软件：
    2.adb install com.asksven.betterbatterystats_2.2.2.0_paid-www.apkhere.com.apk
    3.获取权限：
    adb -d shell pm grant com.asksven.betterbatterystats android.permission.BATTERY_STATS
    4.若依然不可以：
    setenforce 0：取消selinux
    getenforce 查看是否为安全模式 Permissive 则是非安全；
    观察各项参数：
</code></pre><p><strong> rtc闹钟设置与查看 </strong></p>
<pre><code>venus-a3:/ # cat /proc/driver/rtc
rtc_time        : 05:44:49
rtc_date        : 2019-04-26
alrm_time       : 00:00:00
alrm_date       : 1970-01-01
alarm_IRQ       : no
alrm_pending    : no
update IRQ enabled      : no
periodic IRQ enabled    : no
periodic IRQ frequency  : 1
max user IRQ frequency  : 64
24hr            : yes

设置当前时间+100000后唤醒
venus-a3:/ # echo +100000 &gt; /sys/devices/platform/soc/rtc/rtc/rtc0/wakealarm
venus-a3:/ # cat /proc/driver/rtc
rtc_time        : 05:47:15
rtc_date        : 2019-04-26
alrm_time       : 09:33:52
alrm_date       : 2019-04-27
alarm_IRQ       : yes
alrm_pending    : no
update IRQ enabled      : no
periodic IRQ enabled    : no
periodic IRQ frequency  : 1
max user IRQ frequency  : 64
24hr            : yes

echo 0取消

查看闹钟应用设置闹钟：
venus-a3:/ # settings list system | grep  next
       next_alarm_formatted=Wed 11:50 AM
</code></pre><p><strong>怎么捕捉休眠唤醒的systrace</strong><br>    休眠前<br>    atrace –async_start -b 8192 -o /data/trace2.dat gfx view wm am power<br>    唤醒后<br>    atrace –async_stop</p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.cnblogs.com/dyufei/p/8018016.html" target="_blank" rel="noopener">Android7.0 PowerManagerService 之亮灭屏（二） PMS 电源状态管理updatePowerStateLocked（）</a></p>
<p><a href="https://www.jianshu.com/p/b40e1b61e6d2" target="_blank" rel="noopener">Android 保持屏幕常亮的几种方法</a></p>
<p><a href="https://blog.csdn.net/Gaugamela/article/details/52838654" target="_blank" rel="noopener">Android7.0 PowerManagerService(3)核心函数updatePowerStateLocked的主要流程</a></p>
<p><a href="https://blog.csdn.net/fu_kevin0606/article/details/54408094" target="_blank" rel="noopener">Android7.0 PowerManagerService亮灭屏分析(一)</a></p>
<p><a href="https://blog.csdn.net/ysh06201418/article/details/41849191" target="_blank" rel="noopener">wakelock介绍</a></p>
<p><a href="https://jasper-1024.github.io/2017/08/19/linux%E7%AC%94%E8%AE%B0%E2%80%94rtc%E5%AD%90%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">linux笔记–rtc子系统</a></p>
<p><a href="http://ddrv.cn/a/102265" target="_blank" rel="noopener">Android7.0亮屏流程分析</a></p>
<p><a href="https://cronusliang.me/android/2019/06/10/%E9%94%81%E5%B1%8F%E5%88%86%E6%9E%90(9.0" target="_blank" rel="noopener">锁屏分析</a>/)</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/standby-linux/" rel="tag"># standby linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/17/cpu/arm体系架构的发展/" rel="next" title="ARM体系架构概述">
                <i class="fa fa-chevron-left"></i> ARM体系架构概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/13/standby/kernel_suspend/" rel="prev" title="内核的休眠流程">
                内核的休眠流程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dongka</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">安卓电源状态</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">老化休眠唤醒代码demo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">sleep流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">安卓的唤醒流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">android R上的变更</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongka</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
