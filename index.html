<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="知识总结">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="知识总结">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="知识总结">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>知识总结</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">知识总结</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/18/display/MutiDisplay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/18/display/MutiDisplay/" itemprop="url">双屏异显异触流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-18T00:07:09+00:00">
                2019-11-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/display/" itemprop="url" rel="index">
                    <span itemprop="name">display</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="异显apk分析">异显apk分析</span></h1><p>在安卓的SDK中有线程的ApiDemo提供给我们去参考设计</p>
<p>目录为：development/samples/ApiDemos/src/com/example/android/apis/app/PresentationActivity.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCheckedChanged</span><span class="params">(CompoundButton buttonView, <span class="keyword">boolean</span> isChecked)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (buttonView == mShowAllDisplaysCheckbox) &#123;</span><br><span class="line">         <span class="comment">// Show all displays checkbox was toggled.</span></span><br><span class="line">         mDisplayListAdapter.updateContents();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Display item checkbox was toggled.</span></span><br><span class="line">         <span class="keyword">final</span> Display display = (Display)buttonView.getTag();</span><br><span class="line">         <span class="keyword">if</span> (isChecked) &#123;</span><br><span class="line">             DemoPresentationContents contents = <span class="keyword">new</span> DemoPresentationContents(getNextPhoto());</span><br><span class="line">             showPresentation(display, contents);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             hidePresentation(display);</span><br><span class="line">         &#125;</span><br><span class="line">         mDisplayListAdapter.updateContents();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoPresentationSurfaceView</span> <span class="keyword">extends</span> <span class="title">Presentation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GLSurfaceView mSurfaceView;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String TAG = <span class="string">"DemoPresentationActivity"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoPresentationSurfaceView</span><span class="params">(Context context, Display display)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, display);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Be sure to call the super class.</span></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the resources for the context of the presentation.</span></span><br><span class="line">        <span class="comment">// Notice that we are getting the resources from the context of the presentation.</span></span><br><span class="line">        Resources r = getContext().getResources();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inflate the layout.</span></span><br><span class="line">        setContentView(R.layout.presentation_with_media_router_content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the surface view for visual interest.</span></span><br><span class="line">        mSurfaceView = (GLSurfaceView)findViewById(R.id.surface_view);</span><br><span class="line">        mSurfaceView.setRenderer(<span class="keyword">new</span> CubeRenderer(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">final</span> Button button = (Button)findViewById(R.id.textbutton);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span>  </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"There are currently zhuangnanjian"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GLSurfaceView <span class="title">getSurfaceView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mSurfaceView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是通过Button的ID去选择哪个显示设备；安卓还提供了另外两种可以获取Presentation的方法</p>
<p><strong>一：通过Media router去获取首选的设备和显示presentation</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mMediaRouter = (MediaRouter)getSystemService(Context.MEDIA_ROUTER_SERVICE);</span><br><span class="line">MediaRouter.RouteInfo route = mMediaRouter.getSelectedRoute(MediaRouter.ROUTE_TYPE_LIVE_VIDEO);</span><br><span class="line">Display presentation = route != <span class="keyword">null</span> ? route.getPresentationDisplay() :<span class="keyword">null</span>;</span><br><span class="line">presentation.show();</span><br><span class="line">presentation.setOnDismissListener(mOnDismissListener);</span><br></pre></td></tr></table></figure>
<p>除了ROUTE_TYPE_LIVE_VIDEO，还有ROUTE_TYPE_REMOTE_DISPLAY，ROUTE_TYPE_USER</p>
<p><strong>二：使用displayManager获取</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Display[]presentationDisplays = mDisplayManager.getDisplays(DisplayManager.DISPLAY_CATEGORY_PRESENTATION);</span><br><span class="line">Display display = presentationDisplays[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> displayId = display.getDisplayId();</span><br><span class="line">Display display = presentationDisplays[<span class="number">0</span>];</span><br><span class="line">Presentation presentation = <span class="keyword">new</span> MyPresentation(context, presentationDisplay);</span><br><span class="line">presentation.show();</span><br></pre></td></tr></table></figure>
<p>支持的类型如下：</p>
<p><img src="/2019/11/18/display/MutiDisplay/Display类型.png" alt="1571399167593"></p>
<p><strong>综上为三种创建Presentation对象方法，一：直接指定DisplayId，创建Presentation对象；二：通过MediaRoute获取Presentation对象 三：通过displayManager获取Display对象，获取DisplayId,然后创建Presentation对象；然后调用Presentation的show函数</strong>；</p>
<p>接下来我们就进入framework看下这个对象和相关的show函数</p>
<h1><span id="presentationampampshow">Presentation&amp;&amp;show</span></h1><h2><span id="presenation结构体">Presenation结构体</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Presentation</span><span class="params">(Context outerContext, Display display, <span class="keyword">int</span> theme)</span> </span>&#123;              </span><br><span class="line">    <span class="keyword">super</span>(createPresentationContext(outerContext, display, theme), theme, <span class="keyword">false</span>); <span class="comment">//调用dialog的构造函数   </span></span><br><span class="line">                                                                                     </span><br><span class="line">    mDisplay = display;                                                              </span><br><span class="line">    mDisplayManager = (DisplayManager)getContext().getSystemService(DISPLAY_SERVICE);</span><br><span class="line">                                                                                     </span><br><span class="line">    <span class="keyword">final</span> Window w = getWindow();                                                    </span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams attr = w.getAttributes();                       </span><br><span class="line">    attr.token = mToken;                                                             </span><br><span class="line">    w.setAttributes(attr);                                                           </span><br><span class="line">    w.setGravity(Gravity.FILL);                                                      </span><br><span class="line">    w.setType(TYPE_PRESENTATION);                                                    </span><br><span class="line">    setCanceledOnTouchOutside(<span class="keyword">false</span>);                                                </span><br><span class="line">&#125;                   </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Context <span class="title">createPresentationContext</span><span class="params">(                              </span></span></span><br><span class="line"><span class="function"><span class="params">        Context outerContext, Display display, <span class="keyword">int</span> theme)</span> </span>&#123;                    </span><br><span class="line">    <span class="keyword">if</span> (outerContext == <span class="keyword">null</span>) &#123;                                                </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"outerContext must not be null"</span>);   </span><br><span class="line">    &#125;                                                                          </span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;                                                     </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);        </span><br><span class="line">    &#125;                                                                          </span><br><span class="line">                                                                               </span><br><span class="line">    Context displayContext = outerContext.createDisplayContext(display);       </span><br><span class="line">    <span class="keyword">if</span> (theme == <span class="number">0</span>) &#123;                                                          </span><br><span class="line">        TypedValue outValue = <span class="keyword">new</span> TypedValue();                                </span><br><span class="line">        displayContext.getTheme().resolveAttribute(                            </span><br><span class="line">                com.android.internal.R.attr.presentationTheme, outValue, <span class="keyword">true</span>);</span><br><span class="line">        theme = outValue.resourceId;                                           </span><br><span class="line">    &#125;                                                                          </span><br><span class="line">                                                                               </span><br><span class="line">    <span class="comment">// Derive the display's window manager from the outer window manager.      </span></span><br><span class="line">    <span class="comment">// We do this because the outer window manager have some extra information </span></span><br><span class="line">    <span class="comment">// such as the parent window, which is important if the presentation uses  </span></span><br><span class="line">    <span class="comment">// an application window type.                                             </span></span><br><span class="line">    <span class="keyword">final</span> WindowManagerImpl outerWindowManager =                               </span><br><span class="line">            (WindowManagerImpl)outerContext.getSystemService(WINDOW_SERVICE);  </span><br><span class="line">    <span class="keyword">final</span> WindowManagerImpl displayWindowManager =                             </span><br><span class="line">            outerWindowManager.createPresentationWindowManager(displayContext);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextThemeWrapper(displayContext, theme) &#123;                    </span><br><span class="line">        <span class="meta">@Override</span>                                                              </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;                          </span><br><span class="line">            <span class="keyword">if</span> (WINDOW_SERVICE.equals(name)) &#123;                                 </span><br><span class="line">                <span class="keyword">return</span> displayWindowManager;                                   </span><br><span class="line">            &#125;                                                                  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getSystemService(name);                               </span><br><span class="line">        &#125;                                                                      </span><br><span class="line">    &#125;;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Presentation继承自Dialog，获取到Presentation要显示的设备后，就要将Activity的context对象和设备信息作为参数来创建Presentation对象；将设备记录在成员变量mDisplay中，将Presentation设置为不可在外部点击取消；</p>
<h2><span id="show流程">show流程</span></h2><p><img src="/2019/11/18/display/MutiDisplay/show.png" alt="1571476950445"></p>
<p>创建ViewRoot并将view添加到链表上</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">     res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">         getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">         mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">         mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">         mTempInsets);</span><br></pre></td></tr></table></figure>
<p>setView的作用主要有两个：一：创建InputChannel来接受输入事件；二：将Window加入到WindowManager</p>
<h1><span id="输入事件的传递">输入事件的传递</span></h1><h2><span id="输入设备类型">输入设备类型</span></h2><p>从InputReader.h我们可以看出来，安卓将输入设备分为以下几种类型：</p>
<p>开关：SwitchInputMapper</p>
<p>震动器，严格意义上是输出设备：VibratorInputMapper</p>
<p>鼠标：CursorInputMapper</p>
<p>键盘：KeyboardInputMapper</p>
<p>触摸设备 TouchInputMapper，SingleTouchInputMapper，MultiTouchInputMapper,</p>
<p>触控笔ExternalStylusInputMapper,</p>
<p>游戏杆：JoystickInputMapper</p>
<p>input设备不同初始化参数也不一样如触摸设备的话可以配置displayId,而鼠标则只能输出到主显；</p>
<h2><span id="touchdisplayid的配置流程">touch.displayId的配置流程</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">services/inputflinger/InputReader.cpp</span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">	processEventsLocked(mEventBuffer, count);</span><br><span class="line">		addDeviceLocked(rawEvent-&gt;when, rawEvent-&gt;deviceId);</span><br><span class="line">			device-&gt;configure(when, &amp;mConfig, <span class="number">0</span>);</span><br><span class="line">				configureParameters()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mParameters.orientationAware                                                  </span><br><span class="line">        || mParameters.deviceType == Parameters::DEVICE_TYPE_TOUCH_SCREEN         </span><br><span class="line">        || mParameters.deviceType == Parameters::DEVICE_TYPE_POINTER) &#123;           </span><br><span class="line">    mParameters.hasAssociatedDisplay = <span class="literal">true</span>;                                      </span><br><span class="line">    <span class="keyword">if</span> (mParameters.deviceType == Parameters::DEVICE_TYPE_TOUCH_SCREEN) &#123;         </span><br><span class="line">        mParameters.associatedDisplayIsExternal = getDevice()-&gt;isExternal();      </span><br><span class="line">        String8 uniqueDisplayId;                                                  </span><br><span class="line">        getDevice()-&gt;getConfiguration().tryGetProperty(String8(<span class="string">"touch.displayId"</span>),</span><br><span class="line">                uniqueDisplayId);                                                 </span><br><span class="line">        mParameters.uniqueDisplayId = uniqueDisplayId.c_str();                    </span><br><span class="line">    &#125;                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="touchdisplayid的传递流程">touch.displayId的传递流程</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">services/inputflinger/InputReader.cpp</span><br><span class="line"><span class="keyword">void</span> TouchInputMapper::dispatchMotion</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int32_t</span> displayId = getAssociatedDisplay().value_or(ADISPLAY_ID_NONE);</span><br><span class="line">	pointerProperties[pointerCount].copyFrom(properties[index]);</span><br><span class="line">	pointerCoords[pointerCount].copyFrom(coords[index]);        </span><br><span class="line">		<span class="built_in">std</span>::optional&lt;<span class="keyword">int32_t</span>&gt; TouchInputMapper::getAssociatedDisplay() &#123;         </span><br><span class="line">    		<span class="keyword">if</span> (mParameters.hasAssociatedDisplay) &#123;                               </span><br><span class="line">       		<span class="keyword">if</span> (mDeviceMode == DEVICE_MODE_POINTER) &#123;                         </span><br><span class="line">            	<span class="keyword">return</span> <span class="built_in">std</span>::make_optional(mPointerController-&gt;getDisplayId());</span><br><span class="line">        	&#125; <span class="keyword">else</span> &#123;                                                          </span><br><span class="line">            	<span class="keyword">return</span> <span class="built_in">std</span>::make_optional(mViewport.displayId);               </span><br><span class="line">        	&#125;                                                                 </span><br><span class="line">    		&#125;                                                                     </span><br><span class="line">    		<span class="keyword">return</span> <span class="built_in">std</span>::nullopt;                                                  </span><br><span class="line">		&#125;</span><br><span class="line">	NotifyMotionArgs args(mContext-&gt;getNextSequenceNum(), when, deviceId,                   </span><br><span class="line">        source, displayId, policyFlags,                                                 </span><br><span class="line">        action, actionButton, flags, metaState, buttonState, MotionClassification::NONE,</span><br><span class="line">        edgeFlags, deviceTimestamp, pointerCount, pointerProperties, pointerCoords,     </span><br><span class="line">        xPrecision, yPrecision, downTime, <span class="built_in">std</span>::move(frames));                           </span><br><span class="line">	getListener()-&gt;notifyMotion(&amp;args); </span><br><span class="line"></span><br><span class="line">压入队列里面然后在read 的loopOnce中会进行通知</span><br><span class="line">services/inputflinger/InputListener.cpp</span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::notifyConfigurationChanged(          </span><br><span class="line">        <span class="keyword">const</span> NotifyConfigurationChangedArgs* args) &#123;          </span><br><span class="line">    mArgsQueue.push(<span class="keyword">new</span> NotifyConfigurationChangedArgs(*args));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line">    ...</span><br><span class="line">    mQueuedListener-&gt;flush();</span><br><span class="line">    args-&gt;notify(mInnerListener);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">在InputDispatcher中同样是用的一个线程找到对应的窗口进行分发</span><br><span class="line">services/inputflinger/InputDispatcher.cpp</span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyMotion(<span class="keyword">const</span> NotifyMotionArgs* args) &#123;</span><br><span class="line">	...</span><br><span class="line">	needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">	mPolicy-&gt;interceptMotionBeforeQueueing(args-&gt;eventTime, <span class="comment">/*byref*/</span> policyFlags);		</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">	...</span><br><span class="line">	mDispatcher-&gt;dispatchOnce();</span><br><span class="line">		--&gt;mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">			--&gt;dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">				--&gt;done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">                &amp;dropReason, nextWakeupTime);</span><br><span class="line">                	findTouchedWindowTargetsLocked</span><br><span class="line">                	 dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从软件流程分析，touchScreen类型的话是通过配置device.internal来配置TP的输入设备输出到辅显，而Pointer类型的话则是通过displayId去设置输出的方向；</p>
<h1><span id="idc文件配置">idc文件配置</span></h1><p>idc（Input Device Configuration）为输入设备配置文件，包含设备具体的配置属性，这些属性影响输入设备的行为，常见的配置有；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">device.internal 指定输入设备属于内置组件；还是外部链接（很可能拆卸）的外围设备；0表示外部，1表示内部</span><br><span class="line">touch.deviceType   touchScreen(与显示屏相关的触摸屏),touchPad（不与显示相关连的触摸板）,                            touchNavigation,pointer（类似于鼠标）,default(系统根据分类算法自动检测设备类型)</span><br><span class="line">touch.orientationAware  等于1时表示触摸会随着显示屏方向更改，为0则表示不受显示屏方向更改的影响</span><br><span class="line">touch.gestureMode single-touch multi-touch default</span><br><span class="line">touch.wake   tp是否需要唤醒系统，一般希望外部设备才有这种能力；如果是内部的设备需要唤醒系统，你也可以进行配置</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从代码流程上看，在双屏异触的场景下，如果是两个TP，需要配置一个为内部设备，一个为外部设备；</p>
<p>由于安卓的默认鼠标设备的DisplayId只能是0，如代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CursorInputMapper::sync(<span class="keyword">nsecs_t</span> when) &#123;</span><br><span class="line">    ...</span><br><span class="line">        <span class="keyword">if</span> (mSource == AINPUT_SOURCE_MOUSE) &#123;</span><br><span class="line">    <span class="keyword">if</span> (moved || scrolled || buttonsChanged) &#123;</span><br><span class="line">        mPointerController-&gt;setPresentation(</span><br><span class="line">                PointerControllerInterface::PRESENTATION_POINTER);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (moved) &#123;</span><br><span class="line">            mPointerController-&gt;move(deltaX, deltaY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buttonsChanged) &#123;</span><br><span class="line">            mPointerController-&gt;setButtonState(currentButtonState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPointerController-&gt;unfade(PointerControllerInterface::TRANSITION_IMMEDIATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> x, y;</span><br><span class="line">    mPointerController-&gt;getPosition(&amp;x, &amp;y);</span><br><span class="line">    pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_X, x);</span><br><span class="line">    pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_Y, y);</span><br><span class="line">    pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_X, deltaX);</span><br><span class="line">    pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_RELATIVE_Y, deltaY);</span><br><span class="line">    displayId = ADISPLAY_ID_DEFAULT;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_X, deltaX);</span><br><span class="line">   		pointerCoords.setAxisValue(AMOTION_EVENT_AXIS_Y, deltaY);</span><br><span class="line">   	 displayId = ADISPLAY_ID_NONE;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要让鼠标设备支持输出到辅显也可以改变这个displayId,并且需要修改framework/base下对于鼠标控件sprite Layer的LayerStack属性的设置；笔者的话是通过鼠标在主显响应，触摸在辅屏响应来实现双屏异显异触的验证，那么这样其实可以配置；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system/usr/idc/gslX680.idc</span><br><span class="line">	device.internal = 0</span><br><span class="line">	touch.deviceType = touch</span><br></pre></td></tr></table></figure>
<p>总结：作为应用，需要指定送显时候的displayId；作为输入设备也需要指定</p>
<h1><span id="参考链接">参考链接</span></h1><p><a href="https://juejin.im/post/5d2af4ddf265da1b8f1af0eb" target="_blank" rel="noopener">Android折叠屏适配攻略</a></p>
<p><a href="https://segmentfault.com/a/1190000019213936" target="_blank" rel="noopener">聊聊安卓折叠屏给交互设计和开发带来的变化</a></p>
<p><a href="https://walkerkai.wang/Android-Presentation.html" target="_blank" rel="noopener">Android开发-双屏异显（Presentation）实现</a></p>
<p><a href="https://www.jianshu.com/p/6e5eda3a51af" target="_blank" rel="noopener">手把手带你深入浅出神秘的设计模式</a></p>
<p><a href="https://blog.csdn.net/fu_kevin0606/article/details/79420621" target="_blank" rel="noopener">Android7.1 Presentation双屏异显原理分析</a></p>
<p><a href="https://source.android.google.cn/devices/input/touch-devices" target="_blank" rel="noopener">输入输出设备配置文件</a></p>
<p><a href="https://www.jianshu.com/p/34f5c7d55337" target="_blank" rel="noopener">Android触摸事件传递</a></p>
<p><a href="https://cwgoover.github.io/2016/05/31/android-setting-pointer-location/" target="_blank" rel="noopener">Android Input of Pointer Location</a></p>
<p><a href="http://ddrv.cn/a/296013" target="_blank" rel="noopener">Android双屏分析</a></p>
<p><a href="http://liuwangshu.cn/framework/ims/4-inputtarget.html" target="_blank" rel="noopener">输入事件是怎么分发到目标窗口的</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/30/display/rotation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/30/display/rotation/" itemprop="url">androidQ更改默认屏幕方向</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-30T00:07:09+00:00">
                2019-09-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/display/" itemprop="url" rel="index">
                    <span itemprop="name">display</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="屏幕参数方向引入">屏幕参数方向引入</span></h1><p>由于客户的选型,需要更改自身屏幕方向；在P之前的android SDK中，谷歌并不支持相关的功能；所以需要原厂自行定制；在P上 MTK为统一刷GSI和不刷GSI方向的统一，向谷歌mainline提供了对应的补丁；之后在Q上谷歌又进行了相关的修改；使得安卓支持改变默认显示方向的功能也日趋稳定；当然也是会存在bug,如在android Q上就出现了开机动画和应用启动动画异常问题（已解决）；但为了统一后续android平台下的横屏竖用使用配置；全志平台androidQ横屏竖用也是依托这个补丁进行横屏竖用的实现；</p>
<p>有兴趣的可以访问这个网站查看更多的信息：<a href="https://osdn.net/projects/android-x86/scm/git/frameworks-native/commits/7501ed66a05f530062925011d1342e8651216051" target="_blank" rel="noopener">GSI 支持横屏模式</a></p>
<h1><span id="本文目的">本文目的</span></h1><p>一：梳理安卓TP,gsensor,surfaceflinger中rotation的系数之间的关系，客户配置地方；</p>
<p>二：系统旋转监听以及应用旋转方向申请；</p>
<p>三：现有显示框架支持横屏竖用原理；</p>
<h1><span id="参数配置">参数配置</span></h1><h2><span id="dtbo中设置tp方向">dtbo中设置TP方向</span></h2><p>为了分离linux环境（dragonboard）和android环境的中TP的方向，使其不相互影响，为了使用android的新朝向，我们将TP方向更改的配置放到dtbo中；在android source并lunch对应的版型后，cbd即可到对应的路径；本文将以全志A50 A7版型为例讲解配置；</p>
<p><img src="/2019/09/30/display/rotation/boarddts.png" alt="1565697980955"></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;soc &#123;</span><br><span class="line">    dtbo_version = &lt;0x00000001&gt;;</span><br><span class="line">    dtbo&#123;</span><br><span class="line">        compatible = "allwinner,sunxi-dtbo";</span><br><span class="line">        dtbo_type = &lt;1&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="addition">+    ctp &#123;</span></span><br><span class="line"><span class="addition">+        ctp_screen_max_x = &lt;480&gt;;</span></span><br><span class="line"><span class="addition">+        ctp_screen_max_y = &lt;800&gt;;</span></span><br><span class="line"><span class="addition">+        ctp_revert_y_flag = &lt;1&gt;;</span></span><br><span class="line"><span class="addition">+        ctp_exchange_x_y_flag = &lt;0&gt;;</span></span><br><span class="line"><span class="addition">+    &#125;;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ctp_screen_max_x 触摸板的x轴最大坐标</span><br><span class="line">ctp_screen_max_y 触摸板的y轴最大坐标</span><br><span class="line">ctp_revert_x_flag 是否需要翻转x坐标，需要则置1，反之置0</span><br><span class="line">ctp_revert_y_flag 是否需要翻转y坐标，需要则置1，反之置0</span><br><span class="line">ctp_exchange_x_y_flag 是否需要x轴y轴坐标对换</span><br></pre></td></tr></table></figure>
<p>修改好需要重新编译和打包内核，在配置该参数的需注意检查驱动是否支持该方法；</p>
<p><strong>非安全固件可以通过命令行修改参数进行验证</strong>，将default/env.cfg中将bootdelay改成3s,<strong>配合串口</strong>在uboot启动过程中按住enter键进入uboot命令行，用fdt 命令的修改验证；</p>
<p><strong>步骤如下：</strong></p>
<p><img src="/2019/09/30/display/rotation/fdt_ctp.png" alt="1569824097100"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如当下需要修改ctp_screen_max_x,可按如下步骤进行修改</span><br><span class="line">1. fdt set /soc/ctp ctp_screen_max_x &lt;0x01&gt;</span><br><span class="line">2. fdt list /soc/ctp 确认是否修改到</span><br><span class="line">3. fdt save //保存配置</span><br><span class="line">4. boot</span><br></pre></td></tr></table></figure>
<h2><span id="方案目录下配置显示和sensor方向">方案目录下配置显示和sensor方向</span></h2><p><img src="/2019/09/30/display/rotation/mk.png" alt="1565698555002"></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+	# change SurfaceFlinger Orientation(0, 90, 180, 270)</span></span><br><span class="line"><span class="addition">+	PRODUCT_PROPERTY_OVERRIDES += \</span></span><br><span class="line">  		ro.surface_flinger.primary_display_orientation=ORIENTATION_90 \</span><br><span class="line"><span class="addition">+	#change minui Orientation</span></span><br><span class="line"><span class="addition">+	#ROTATION_NONE=0, ROTATION_RIGHT=90, ROTATION_DOWN=180, ROTATION_LEFT=270</span></span><br><span class="line"><span class="addition">+	PRODUCT_SYSTEM_DEFAULT_PROPERTIES += \</span></span><br><span class="line">   		 ro.minui.default_rotation=ROTATION_RIGHT</span><br><span class="line"><span class="addition">+	#change Gsensor rotation(0, 90, 180. 270)</span></span><br><span class="line"><span class="addition">+	PRODUCT_PROPERTY_OVERRIDES += \</span></span><br><span class="line">    	ro.vendor.sf.rotation=270</span><br></pre></td></tr></table></figure>
<h2><span id="camera方向配置">camera方向配置</span></h2><p>在有摄像头的方案下面还需调整自己的摄像头方向，提供的配置地方有：</p>
<p>configs/camera.cfg</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">camera_orientation //可设置0，90，180，270</span><br></pre></td></tr></table></figure>
<p>hawkview/sensor_list_cfg.ini</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sensor_hflip0  //水平反转</span><br><span class="line">sensor_vflip0  //垂直反转</span><br></pre></td></tr></table></figure>
<p>客户可以adb remount,选择busybox vi到对应的文件下；先调整camera的朝向，在调整镜像；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vendor/etc/camera.cfg</span><br><span class="line">vendor/etc/hawkview/sensor_list_cfg.ini</span><br></pre></td></tr></table></figure>
<h2><span id="gsensor方向调整方法二">Gsensor方向调整方法二</span></h2><p>对于Gsensor还有一种改法与camera一样，在方案目录下面有相应的文件可以提供配置;方案商的话其实根据想要的屏幕朝向和sensor的摆放，配置这个文件会是一件更为简单和兼容性更好的操作；</p>
<p>目录为config/gsensor.cfg,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gsensor_name = sc7660</span><br><span class="line">gsensor_direct_x = <span class="literal">false</span> <span class="comment">//x轴是否反向</span></span><br><span class="line">gsensor_direct_y = <span class="literal">false</span> <span class="comment">//y轴是否反向</span></span><br><span class="line">gsensor_direct_z = <span class="literal">false</span> <span class="comment">//z轴是否反向</span></span><br><span class="line">gsensor_xy_revert = <span class="literal">true</span> <span class="comment">//是否反转x,y轴</span></span><br></pre></td></tr></table></figure>
<p><strong>gsensor坐标系：</strong></p>
<p><img src="/2019/09/30/display/rotation/gsensor方向.png" alt="gsensor方向"></p>
<p><strong>匹配规则：</strong></p>
<p>安卓是用的右手坐标系，Z轴相对屏幕朝外，gsensor的数据是一个三维数组，values[0]对应的x轴的值，value[1]对应的y轴,value[2]对应的Z轴，将相对轴竖直朝上放置时候，以该轴为对应的值为正（约9.8左右），其他两轴对应为0为准；</p>
<h2><span id="总结">总结</span></h2><p>对于Q平台上需要更改默认屏幕方向，为兼容多个设备，且统一后续平台谷歌方案配置需要配置的选项如上述所述配置Android显示方向，recovery显示方向，TP方向，gsensor，camera，以及bootlogo图片方向；</p>
<p><strong>至此，若是只需要知道怎么配置的可以不看以下的章节；</strong></p>
<h1><span id="input系统">Input系统</span></h1><h2><span id="linux-input简介">linux input简介</span></h2><h3><span id="软件框图">软件框图</span></h3><p><img src="/2019/09/30/display/rotation/1565673944332.png" alt="1565673944332"></p>
<h3><span id="tp驱动流程">Tp驱动流程</span></h3><p>借着梳理这个事件上报流程，我们也可以将主要的架构和流程涵盖；</p>
<p><strong>以TP gslx680为例：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span>  <span class="title">gsl_ts_probe</span><span class="params">(struct i2c_client *client,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> struct i2c_device_id *id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">   queue_work(gslX680_wq, &amp;glsX680_init_work);</span><br><span class="line">    	--&gt;glsX680_init_events	</span><br><span class="line">            ret = input_request_int(&amp;(config_info.input_type), gsl_ts_irq,</span><br><span class="line">            CTP_IRQ_MODE, ts_init);</span><br><span class="line"></span><br><span class="line">   gsl_ts_init_ts</span><br><span class="line">     --&gt;set_bit(ABS_MT_POSITION_X, input_device-&gt;absbit);</span><br><span class="line"> 		set_bit(ABS_MT_POSITION_Y, input_device-&gt;absbit);</span><br><span class="line">		set_bit(ABS_MT_TOUCH_MAJOR, input_device-&gt;absbit);</span><br><span class="line">    	set_bit(ABS_MT_WIDTH_MAJOR, input_device-&gt;absbit);</span><br><span class="line">		input_set_abs_params(input_device, ABS_MT_POSITION_X, <span class="number">0</span>,</span><br><span class="line">                         SCREEN_MAX_X, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	input_set_abs_params(input_device, ABS_MT_POSITION_Y, <span class="number">0</span>,</span><br><span class="line">                         SCREEN_MAX_Y, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	input_set_abs_params(input_device, ABS_MT_TOUCH_MAJOR, <span class="number">0</span>,</span><br><span class="line">                         PRESS_MAX, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	input_set_abs_params(input_device, ABS_MT_WIDTH_MAJOR, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    	设置TP支持的设备属性和参数</span><br><span class="line">        --&gt;  input_device = input_allocate_device();</span><br><span class="line">    		 c = input_register_device(input_device);</span><br><span class="line">    		 跟常见的platform总线模型一样，会将input_device加到input_device_list</span><br><span class="line">    		 在<span class="keyword">register</span>的时候通过match在input_handler_list中找到对应的handler</span><br><span class="line">             流程如下所示：</span><br><span class="line">             --&gt; input_attach_handler(dev, handler);</span><br><span class="line">    			  id = input_match_device(handler, dev);</span><br><span class="line">    			  error = handler-&gt;connect(handler, dev, id);</span><br><span class="line">    		这里就会调到：evdev.c中的event_connect</span><br><span class="line">    			--&gt;error = input_register_handle(&amp;evdev-&gt;handle);</span><br><span class="line">    		evdev基本上支持所有类型，所以这里TP将会与evdev通过handle进行连接</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">接下来就是中断处理流程，这里我们就能看出他的层级关系；  </span><br><span class="line">input driver  --&gt;input_dev</span><br><span class="line">gsl_ts_irq&#123;</span><br><span class="line">	queue_work(ts-&gt;wq, &amp;ts-&gt;work);</span><br><span class="line">		gsl_ts_xy_worker</span><br><span class="line">			process_gslX680_data</span><br><span class="line">				input_report_abs(ts-&gt;input, ABS_MT_TRACKING_ID, id);</span><br><span class="line">				input_report_abs(ts-&gt;input, ABS_MT_TOUCH_MAJOR, pressure);</span><br><span class="line">				input_report_abs(ts-&gt;input, ABS_MT_POSITION_X, x);</span><br><span class="line">				input_report_abs(ts-&gt;input, ABS_MT_POSITION_Y, y);</span><br><span class="line">				input_report_abs(ts-&gt;input, ABS_MT_WIDTH_MAJOR, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">input core</span><br><span class="line">input_event(dev, EV_ABS, code, value);</span><br><span class="line">	input_handle_event(dev, type, code, value);</span><br><span class="line">		input_pass_values(dev, dev-&gt;vals, dev-&gt;num_vals);</span><br><span class="line">			count = input_to_handler(handle, vals, count);</span><br><span class="line">				handler-&gt;event(handle, v-&gt;type, v-&gt;code, v-&gt;value);</span><br><span class="line">evdev --&gt; input_handler</span><br><span class="line">evdev_event</span><br><span class="line">	evdev_events(handle, vals, <span class="number">1</span>);</span><br><span class="line">		evdev_pass_values(client, vals, count, ev_time);</span><br><span class="line">			__pass_event(client, &amp;event);</span><br><span class="line">			--&gt;kill_fasync(&amp;client-&gt;fasync, SIGIO, POLL_IN);</span><br><span class="line">			<span class="comment">//走到这里的时候epoll_wait dev/input/xxx的监听就能收到消息</span></span><br><span class="line">			wake_up_interruptible(&amp;evdev-&gt;wait);</span><br></pre></td></tr></table></figure>
<p><strong>简而言之：input_dev在中断处理函数里面上报事件 -&gt; input_core找到对应的handler -&gt; input_handler:如edev通过___pass_event将事件上报给用户层；</strong></p>
<h2><span id="android-input流程">android Input流程</span></h2><p><a href="https://blog.csdn.net/xingchenxuanfeng/article/details/79208005" target="_blank" rel="noopener">安卓接受事件之后的处理流程</a></p>
<p><img src="/2019/09/30/display/rotation/Android_input.png" alt="android处理input事件处理流程"></p>
<p><strong>流程简单介绍：</strong></p>
<p><strong>一：APP setView建立inputChannel和window的连接</strong></p>
<p>当一个应用程序有Activity能接受用户输入，他就要将自己的Window（ViewRoot）通过setView（)注册到Window Manager Service中；</p>
<p>frameworks/base/core/java/android/view/ViewRootImpl.java</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    requestLayout();<span class="comment">//对控件树进行测量，布局，向WMS申请修改窗口属性以及重绘的所有工作</span></span><br><span class="line">    <span class="keyword">if</span> ((mWindowAttributes.inputFeatures</span><br><span class="line">        &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">   		 mInputChannel = <span class="keyword">new</span> InputChannel();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//服务端过程</span></span><br><span class="line">    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">        getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">        mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">        mTempInsets);</span><br><span class="line">    --&gt; mService.addWindow</span><br><span class="line">        --&gt;openInputChannel</span><br><span class="line">        	InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);</span><br><span class="line">    		mInputChannel = inputChannels[<span class="number">0</span>];</span><br><span class="line">			mClientChannel = inputChannels[<span class="number">1</span>];</span><br><span class="line">    		--&gt;mClientChannel.transferTo(outInputChannel);<span class="comment">//将socketPair的另外一个FD放在参数OutputChannel里，创建WindowInputEventRecevier用于接受InputDispatchor传来的事件；后者同样通过AddFd()将读端SocketFd加入到Looper中，这样一旦InputDispatchor发送Event,Looper就会立即醒来处理；</span></span><br><span class="line">    		--&gt;mWmService.mInputManager.registerInputChannel(mInputChannel, mClient.asBinder());<span class="comment">//调用到InputDispacher的RegisterInputChannel()方法；InputDispacher会通过addFd 将channel的fd加入到loop中，这样，只要某个Window在Socket的另一端写入数据，Looper就会马上从睡眠中醒来，进行处理；</span></span><br><span class="line"></span><br><span class="line">         mInputEventReceiver = <span class="keyword">new</span> WindowInputEventReceiver(mInputChannel,</span><br><span class="line">         Looper.myLooper());</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>建立Window和InputDispatch的联系；</strong></p>
<p><strong>二：framework层的收集和分发</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">framework/native/services/inputflinger/EventHub.cpp</span><br><span class="line">EventHub::EventHub(<span class="keyword">void</span>) : ｛</span><br><span class="line">	mEpollFd = epoll_create1(EPOLL_CLOEXEC);</span><br><span class="line">	mINotifyFd = inotify_init();</span><br><span class="line">	mInputWd = inotify_add_watch(mINotifyFd, DEVICE_PATH, IN_DELETE | IN_CREATE);</span><br><span class="line">	<span class="keyword">int</span> result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mINotifyFd, &amp;eventItem);</span><br><span class="line">	result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);</span><br><span class="line">	result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, &amp;eventItem);</span><br><span class="line">｝</span><br><span class="line"><span class="keyword">size_t</span> EventHub::getEvents(<span class="keyword">int</span> timeoutMillis, RawEvent* buffer, <span class="keyword">size_t</span> bufferSize) &#123;</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">	...</span><br><span class="line">	nRead = read(mWakeReadPipeFd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">	<span class="keyword">int</span> pollResult = epoll_wait(mEpollFd, mPendingEventItems, EPOLL_MAX_EVENTS, timeoutMillis);</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line">｝</span><br><span class="line">总结：Eventhub的作用是监听，读取/dev/input目录下产生的新事件，如节点的增删以及事件的上报，并封装成RawEvent结构体共InputReader使用。</span><br><span class="line">framework/native/services/inputflinger/InputReader.cpp</span><br><span class="line"><span class="keyword">void</span> InputReader::loopOnce() &#123;</span><br><span class="line"><span class="keyword">size_t</span> count = mEventHub-&gt;getEvents(timeoutMillis, mEventBuffer, EVENT_BUFFER_SIZE);</span><br><span class="line">	<span class="keyword">if</span> (count) &#123;</span><br><span class="line">    	processEventsLocked(mEventBuffer, count);</span><br><span class="line">    	--&gt;device-&gt;process(rawEvents, count);</span><br><span class="line">    		--&gt;mapper-&gt;process(rawEvent); <span class="comment">//将事件压入队列</span></span><br><span class="line">	&#125;</span><br><span class="line">	mQueuedListener-&gt;flush();<span class="comment">//将事件进行分发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> TouchInputMapper::process(<span class="keyword">const</span> RawEvent* rawEvent) &#123;</span><br><span class="line">...</span><br><span class="line">	sync(rawEvent-&gt;when);</span><br><span class="line">	--&gt;processRawTouches(<span class="literal">false</span> <span class="comment">/*timeout*/</span>)</span><br><span class="line">		--&gt;cookAndDispatch(mCurrentRawState.when);</span><br><span class="line">			--&gt;dispatchTouches(when, policyFlags);</span><br><span class="line">				--&gt;	dispatchMotion(when, policyFlags, mSource,</span><br><span class="line">        	AMOTION_EVENT_ACTION_MOVE, <span class="number">0</span>, <span class="number">0</span>, metaState, buttonState,</span><br><span class="line">        	AMOTION_EVENT_EDGE_FLAG_NONE,</span><br><span class="line">        	mCurrentCookedState.deviceTimestamp,</span><br><span class="line">        	mCurrentCookedState.cookedPointerData.pointerProperties,</span><br><span class="line">        	mCurrentCookedState.cookedPointerData.pointerCoords,</span><br><span class="line">        	mCurrentCookedState.cookedPointerData.idToIndex,</span><br><span class="line">        	currentIdBits, <span class="number">-1</span>,</span><br><span class="line">        	mOrientedXPrecision, mOrientedYPrecision, mDownTime);</span><br><span class="line">        		--&gt;getListener()-&gt;notifyMotion(&amp;args);</span><br><span class="line">        		--&gt;mArgsQueue.push_back(<span class="keyword">new</span> NotifySwitchArgs(*args));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> QueuedInputListener::flush() &#123;</span><br><span class="line">	args-&gt;notify(mInnerListener);</span><br><span class="line">		--&gt;listener-&gt;notifyMotion(<span class="keyword">this</span>);<span class="comment">//这里的listen就是InputDispatcher了</span></span><br><span class="line">	 mArgsQueue.clear();</span><br><span class="line">&#125;</span><br><span class="line">总结：InputReader的就是循环的读取EventHub中的数据，然后通过InputDispatcher进行分发</span><br><span class="line"></span><br><span class="line">framework/native/services/inputflinger/InputDispatcher.cpp</span><br><span class="line"><span class="keyword">void</span> InputDispatcher::notifyMotion(<span class="keyword">const</span> NotifyMotionArgs* args) &#123;</span><br><span class="line">MotionEntry* newEntry = <span class="keyword">new</span> MotionEntry(args-&gt;sequenceNum, args-&gt;eventTime,</span><br><span class="line">        args-&gt;deviceId, args-&gt;source, args-&gt;displayId, policyFlags,</span><br><span class="line">        args-&gt;action, args-&gt;actionButton, args-&gt;flags,</span><br><span class="line">        args-&gt;metaState, args-&gt;buttonState, args-&gt;classification,</span><br><span class="line">        args-&gt;edgeFlags, args-&gt;xPrecision, args-&gt;yPrecision, args-&gt;downTime,</span><br><span class="line">        args-&gt;pointerCount, args-&gt;pointerProperties, args-&gt;pointerCoords, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        needWake = enqueueInboundEventLocked(newEntry);</span><br><span class="line">	</span><br><span class="line">	interceptMotionBeforeQueueingNonInteractive</span><br><span class="line">	--&gt;InputManagerService.interceptMotionBeforeQueueingNonInteractive</span><br><span class="line">	   InputMonitor.interceptMotionBeforeQueueingNonInteractive</span><br><span class="line">	   PhoneWindowManager.interceptMotionBeforeQueueingNonInteractive</span><br><span class="line">	   PhoneWindowManager.wakeUp</span><br><span class="line">	   PowerManagerService$BinderService.wakeUp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> InputDispatcherThread::threadLoop() &#123;</span><br><span class="line">	mDispatcher-&gt;dispatchOnce();</span><br><span class="line">	--&gt;dispatchOnceInnerLocked(&amp;nextWakeupTime);</span><br><span class="line">		--&gt;done = dispatchMotionLocked(currentTime, typedEntry,</span><br><span class="line">        &amp;dropReason, nextWakeupTime);</span><br><span class="line">          --&gt;injectionResult = findTouchedWindowTargetsLocked(currentTime,</span><br><span class="line">        entry, inputTargets, nextWakeupTime, &amp;conflictingPointerActions);</span><br><span class="line">          --&gt;dispatchEventLocked(currentTime, entry, inputTargets);</span><br><span class="line">          	--&gt;getConnectionIndexLocked(inputTarget.inputChannel);<span class="comment">//这个inputChannel用于与window实例通信</span></span><br><span class="line">          	--&gt;prepareDispatchCycleLocked</span><br><span class="line">          		--&gt;enqueueDispatchEntriesLocked</span><br><span class="line">          			--&gt;startDispatchCycleLocked</span><br><span class="line">          				--&gt;publishMotionEvent</span><br><span class="line">          					--&gt;mChannel-&gt;sendMessage(&amp;msg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">InputDispatcher的作用就是通过sendMessage进行跨进程通信，把msg发给对应的window</span><br><span class="line">如果是按键类型的时间，那么就会通过notifyKey的流程，然后传递给PhoneWindowManager这个读者可以自行梳理</span><br></pre></td></tr></table></figure>
<p><strong>流程总结：</strong>内核将原始事件写入设备节点中，InputReader不断地通过Eventhub将原始事件取出来并翻译加工成android输入事件，然后交给InputDispacther.InputDispactcher根据WMS提供的窗口信息，将事件交给格式的窗口，窗口的ViewRootimpl对象再沿着控件树将事件派发给感兴趣的控件，控件对其接收到的事件做出响应，更新自己的画面，执行特定的动作；当事件处理完成后，会执行finishInputEvent()方法，在进一步调用InputConsumer:sendFinshedSignal告知InputDispatcher线程事件已经处理完成，InputDispatch完成后，最终会调用doDispatchCycleFinishedLockedInterrupttible方法将dispacthEntry从等待队列里面移除；</p>
<p>如Gityuan总结的图片所示</p>
<p><img src="/2019/09/30/display/rotation/input_summary.jpg" alt="input"></p>
<h1><span id="显示方向旋转">显示方向旋转</span></h1><p>Sensor的框架分为三个层次，客户层，服务层，HAL层，服务端负责从HAL层读取数据，并将数据写到管道中，客户端通过管道读取服务端数据；具体细节可以看这两份文档</p>
<p><a href="http://kernel.meizu.com/android-sensor-framework.html" target="_blank" rel="noopener">Android Sensor Framework概览</a></p>
<p><a href="https://www.cnblogs.com/lcw/p/3402770.html" target="_blank" rel="noopener">sensor框架Framework层解读</a></p>
<p><strong>流程图：</strong></p>
<p><img src="/2019/09/30/display/rotation/gsensor_flow.png" alt="1567068378839"></p>
<h2><span id="自动旋转监听">自动旋转监听</span></h2><p>系统从SystemUI或者setting中获取到是否开启自动旋转；最终设置到mUserRotationMode和mUserRotation</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">systemUI:	</span><br><span class="line">./services/core/java/com/android/server/wm/DisplayRotation.java</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freezeRotation</span><span class="params">(<span class="keyword">int</span> rotation)</span> </span>&#123;</span><br><span class="line">     rotation = (rotation == <span class="number">-1</span>) ? mDisplayContent.getRotation() : rotation;</span><br><span class="line">     setUserRotation(WindowManagerPolicy.USER_ROTATION_LOCKED, rotation);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">thawRotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setUserRotation(WindowManagerPolicy.USER_ROTATION_FREE, mUserRotation);</span><br><span class="line">&#125;</span><br><span class="line">settings:</span><br><span class="line">updateSettings() &#123;</span><br><span class="line">    final <span class="keyword">int</span> userRotation = Settings.System.getIntForUser(resolver,</span><br><span class="line">        Settings.System.USER_ROTATION, Surface.ROTATION_0,</span><br><span class="line">        UserHandle.USER_CURRENT);</span><br><span class="line">     final <span class="keyword">int</span> userRotationMode = Settings.System.getIntForUser(resolver,</span><br><span class="line">         Settings.System.ACCELEROMETER_ROTATION, <span class="number">0</span>, UserHandle.USER_CURRENT) != <span class="number">0</span></span><br><span class="line">                 ? WindowManagerPolicy.USER_ROTATION_FREE</span><br><span class="line">                 : WindowManagerPolicy.USER_ROTATION_LOCKED;</span><br><span class="line">    updateOrientationListenerLw()</span><br><span class="line">        --&gt;mOrientationListener.enable(<span class="literal">true</span> <span class="comment">/* clearCurrentRotation */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">services/core/java/com/android/server/policy/WindowOrientationListener.java</span><br><span class="line">一：注册监听</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">(boolean clearCurrentRotation)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (mSensor.getType() == Sensor.TYPE_ACCELEROMETER) &#123;</span><br><span class="line">    	mSensorManager.registerListener(</span><br><span class="line">            mOrientationJudge, mSensor, mRate, DEFAULT_BATCH_LATENCY, mHandler);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   		mSensorManager.registerListener(mOrientationJudge, mSensor, mRate, mHandler);</span><br><span class="line">	&#125;</span><br><span class="line">二：sensor有数据的时候就会发一个回调</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">	这里就会计算出一个proposedRotation，分发给需要的模块</span><br><span class="line">	 onProposedRotationChanged(proposedRotation);</span><br><span class="line">｝</span><br><span class="line">services/core/java/com/android/server/wm/DisplayRotation.java </span><br><span class="line">三：决策是否旋转和启动旋转动画流程</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Send interaction hint to improve redraw performance.</span></span><br><span class="line">     mService.mPowerManagerInternal.powerHint(PowerHint.LAUNCH, <span class="number">1</span>);</span><br><span class="line">     <span class="keyword">if</span> (isRotationChoicePossible(mCurrentAppOrientation)) &#123;</span><br><span class="line">         final boolean isValid = isValidRotationChoice(mRotation);</span><br><span class="line">         sendProposedRotationChangeToStatusBarInternal(mRotation, isValid);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         mService.updateRotation(<span class="literal">false</span> <span class="comment">/* alwaysSendConfiguration */</span>,</span><br><span class="line">                 <span class="literal">false</span> <span class="comment">/* forceRelayout */</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="rotation和orientation区别">rotation和orientation区别</span></h2><p><strong>rotation:</strong>旋转方向是指界面（不是手机）相对于默认情况情况顺时针旋转的角度，平板一般默认横屏，而小屏幕设备默认竖屏；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/view/Surface.java</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ROTATION_0 = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ROTATION_90 = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ROTATION_180 = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">int</span> ROTATION_270 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><strong>orientation:</strong>分为两种情况，一个是ActivityInfo.java,另一个在Configuration.java.前者具体来说是ActivityInfo.screenOrientation,这个值用于记录App强制设定的方向或者旋转模式。具体代码如下：</p>
<p><strong>rotation旋转的是物体坐标系，而orientation旋转的是世界坐标系，即观察视角；</strong></p>
<h2><span id="应用申请旋转">应用申请旋转</span></h2><p>对于应用开发者而言可以通过调用如下api去申请屏幕朝向</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">core/java/android/app/Activity.java</span><br><span class="line">	setRequestedOrientation</span><br></pre></td></tr></table></figure>
<p>获取命令如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpsys window | grep mCurrentAppOrientation</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">frameworks/base/core/java/android/content/pm/ActivityInfo.java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The preferred screen orientation this activity would like to run in.</span></span><br><span class="line"><span class="comment"> * From the &#123;@link android.R.attr#screenOrientation&#125; attribute, one of</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_UNSPECIFIED&#125;, -1；//未指定，默认值，由安卓选择合适方向，关闭系统旋转屏幕，就不会转动屏幕</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_LANDSCAPE&#125;, 0//横屏</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_PORTRAIT&#125;, 1//竖屏</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_USER&#125;, 2//用户选择方向</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_BEHIND&#125;, 3//继承Activity堆栈中当前Activity下面的那个Activity的方向</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_SENSOR&#125;, 4//由物理感应器决定显示方向</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_NOSENSOR&#125;, 5//忽略物理感应器</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_SENSOR_LANDSCAPE&#125;, 6//锁定屏幕横屏，可以180旋转，相当于SCREEN_ORIENTATION_USER_LANDSCAPE并且打开自动旋转功能</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_SENSOR_PORTRAIT&#125;,  7//锁定屏幕竖屏，可以180旋转</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_REVERSE_LANDSCAPE&#125;, 8//强制横屏方向</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_REVERSE_PORTRAIT&#125;, 9//竖屏方向转换</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_FULL_SENSOR&#125;, 10//当手机底部朝上时，根据重力变换朝向，形成相对竖屏旋转180的效果</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_USER_LANDSCAPE&#125;, 11//横屏显示，当打开自动旋转功能时，如果用户在横屏方向上调整方位，屏幕也会跟着变动</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_USER_PORTRAIT&#125;, 12//竖屏显示</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_FULL_USER&#125;, 13//相当于默认打开自动旋转功能</span></span><br><span class="line"><span class="comment"> * &#123;@link #SCREEN_ORIENTATION_LOCKED&#125;,14 //锁定屏幕方向</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>流程图如下所示：</p>
<p><img src="/2019/09/30/display/rotation/setRequestOrientation.png" alt="setRequestOrientation"></p>
<h1><span id="横屏竖用原理">横屏竖用原理</span></h1><h2><span id="参数设置流程介绍">参数设置流程介绍</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">hardware/interface</span><br><span class="line">configstore/<span class="number">1.1</span>/<span class="keyword">default</span>/surfaceflinger.mk</span><br><span class="line">	LOCAL_CFLAGS += -DPRIMARY_DISPLAY_ORIENTATION=$(SF_PRIMARY_DISPLAY_ORIENTATION)</span><br><span class="line">configstore/<span class="number">1.1</span>/<span class="keyword">default</span>/SurfaceFlingerConfigs.cpp</span><br><span class="line">	Return&lt;<span class="keyword">void</span>&gt; SurfaceFlingerConfigs::primaryDisplayOrientation(</span><br><span class="line">    	...</span><br><span class="line">    	orientation = PRIMARY_DISPLAY_ORIENTATION;</span><br><span class="line">    	...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">services/surfaceflinger/SurfaceFlingerProperties.cpp</span><br><span class="line">SurfaceFlingerProperties::primary_display_orientation_values primary_display_orientation(</span><br><span class="line">        SurfaceFlingerProperties::primary_display_orientation_values defaultValue) &#123;</span><br><span class="line">    ...</span><br><span class="line">DisplayOrientation result =</span><br><span class="line">        getDisplayOrientation&lt;V1_1::ISurfaceFlingerConfigs,</span><br><span class="line">                              &amp;V1_1::ISurfaceFlingerConfigs::primaryDisplayOrientation&gt;(</span><br><span class="line">                configDefault);</span><br><span class="line">    <span class="keyword">return</span> SurfaceFlingerProperties::...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">services/surfaceflinger/SurfaceFlinger.cpp</span><br><span class="line">	SurfaceFlinger::primaryDisplayOrientation = DisplayState::...</span><br><span class="line">    creationArgs.displayInstallOrientation = isInternalDisplay ? 			primaryDisplayOrientation : DisplayState::eOrientationDefault;</span><br></pre></td></tr></table></figure>
<h2><span id="应用欺骗">应用欺骗</span></h2><p>在SurfaceFlinger中初始化<strong>primaryDisplayOrientation</strong>，当应用获取显示配置的时候getDisplayConfigs，此时的应用就能够获取到对应的竖屏配置了；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> SurfaceFlinger::getDisplayConfigs(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; displayToken,</span><br><span class="line">                                           Vector&lt;DisplayInfo&gt;* configs) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (displayId == getInternalDisplayIdLocked() &amp;&amp;</span><br><span class="line">    primaryDisplayOrientation &amp; DisplayState::eOrientationSwapMask) &#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(info.w, info.h);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="显示欺骗">显示欺骗</span></h2><p>在DisplayDevice中就会初始化<strong>mDisplayInstallOrientation</strong>,在设置矩阵的时候oritentationToTransform就会被篡改；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DisplayDevice::setProjection(<span class="keyword">int</span> orientation,</span><br><span class="line">        <span class="keyword">const</span> Rect&amp; newViewport, <span class="keyword">const</span> Rect&amp; newFrame) &#123;</span><br><span class="line">    ...</span><br><span class="line">     <span class="keyword">if</span> (isPrimary()) &#123;</span><br><span class="line">     DisplayDevice::orientationToTransfrom(</span><br><span class="line">             (orientation + mDisplayInstallOrientation) % (DisplayState::eOrientation270 + <span class="number">1</span>),</span><br><span class="line">             w, h, &amp;R);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这样给到GPU的Transform就会被欺骗带有一个角度；</p>
<p><img src="/2019/09/30/display/rotation/bufferTransform.png" alt="1567234573802"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">system/core/libsystem/include/system/graphics-base-v1<span class="number">.0</span>.h</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    HAL_TRANSFORM_FLIP_H = <span class="number">1</span>,   <span class="comment">// (1 &lt;&lt; 0)</span></span><br><span class="line">    HAL_TRANSFORM_FLIP_V = <span class="number">2</span>,   <span class="comment">// (1 &lt;&lt; 1)</span></span><br><span class="line">    HAL_TRANSFORM_ROT_90 = <span class="number">4</span>,   <span class="comment">// (1 &lt;&lt; 2)</span></span><br><span class="line">    HAL_TRANSFORM_ROT_180 = <span class="number">3</span>,  <span class="comment">// (FLIP_H | FLIP_V)</span></span><br><span class="line">    HAL_TRANSFORM_ROT_270 = <span class="number">7</span>,  <span class="comment">// ((FLIP_H | FLIP_V) | ROT_90)</span></span><br><span class="line">&#125; <span class="keyword">android_transform_t</span>;</span><br><span class="line"></span><br><span class="line">include/gui/LayerState.h</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisplayState</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        eOrientationDefault = <span class="number">0</span>,</span><br><span class="line">        eOrientation90 = <span class="number">1</span>,</span><br><span class="line">        eOrientation180 = <span class="number">2</span>,</span><br><span class="line">        eOrientation270 = <span class="number">3</span>,</span><br><span class="line">        eOrientationUnchanged = <span class="number">4</span>,</span><br><span class="line">        eOrientationSwapMask = <span class="number">0x01</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>这样就实现了从应用到显示横屏竖用的欺骗流程</p>
<h1><span id="其他">其他</span></h1><h2><span id="常见命令">常见命令</span></h2><h3><span id="模拟输入事件">模拟输入事件</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 模拟文本 input text &quot;hello,word&quot;</span><br><span class="line">2. 模拟按键 input keyevent POWER</span><br><span class="line">3. 模拟滑动 input swipe 0 20 300 500 </span><br><span class="line">4. 模拟屏幕轻触：input tap 100 400</span><br><span class="line">5. 获取输入事件的总类：getevent -p</span><br><span class="line">6. input keyevent --longpress POWER</span><br></pre></td></tr></table></figure>
<h3><span id="旋转事件">旋转事件</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">settings put system accelerometer_rotation 0 //关闭自动旋转</span><br><span class="line">settings put system user_rotation 0</span><br><span class="line">settings put system user_rotation 3</span><br></pre></td></tr></table></figure>
<h3><span id="安卓触点显示">安卓触点显示</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">settings put system show_touches 1</span><br><span class="line">settings put system pointer_location 1</span><br></pre></td></tr></table></figure>
<h3><span id="传感器">传感器</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以利用查看目前sensor上报的事件值</span><br><span class="line">dumpsys sensorservice | grep wall</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/30/display/rotation/sensor_data.png" alt="1566995553990"></p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://zhuanlan.zhihu.com/p/31210271" target="_blank" rel="noopener">一次触摸，Android到底干了啥</a></p>
<p><a href="http://benzblog.site/2017/06/19/all-about-rotations/" target="_blank" rel="noopener">Android屏幕旋转源码探索及应用实践</a></p>
<p><a href="https://www.twblogs.net/a/5c37805fbd9eee35b21d5f5a/zh-cn" target="_blank" rel="noopener">Android P图形显示系统</a></p>
<p><a href="https://www.cnblogs.com/samchen2009/p/3368158.html" target="_blank" rel="noopener">图解Android-AndroidGUI 系统（5）-Android的Event Input System</a></p>
<p><a href="https://juejin.im/post/5b6948086fb9a04fb87771fb" target="_blank" rel="noopener">Android硬件加速（二）-RenderThread与OpenGL GPU渲染</a></p>
<p><a href="http://gityuan.com/2015/09/06/android-anaimator-4/" target="_blank" rel="noopener">源码解读Android属性动画</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/android-animation/1.html" target="_blank" rel="noopener">动画详解</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/deep-android-v1/surface.html" target="_blank" rel="noopener">深入理解surface</a></p>
<p><a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="noopener">应用绘制流程</a></p>
<p><a href="https://developer.android.com/reference/android/R.attr.html#screenOrientation" target="_blank" rel="noopener">screenOrientation参数解析</a></p>
<p><a href="https://blog.csdn.net/jinzhuojun/article/details/50085491" target="_blank" rel="noopener">Android中的转屏流程</a></p>
<p><a href="http://gityuan.com/2016/12/31/input-ipc/" target="_blank" rel="noopener">Input系统-事件处理全过程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/standby/alarm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/standby/alarm/" itemprop="url">alarm机制概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-18T00:07:09+00:00">
                2019-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/standby/" itemprop="url" rel="index">
                    <span itemprop="name">standby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="常用消息机制">常用消息机制</span></h1><p>安卓有很多消息传递机制，基于不用使用场景，我们会采用对应的消息传递机制，而无论是那种消息传递机制，都是按照消息发送者和消息接收者这个进行设计的，以下是我们在不同场景下会选择的消息传送机制；</p>
<h2><span id="同一app内部的同一组件内的消息通信单个或多个线程之间">同一app内部的同一组件内的消息通信（单个或多个线程之间） ；</span></h2><p>   <strong>常用方法：Message Handler/Message Loop</strong></p>
<p>   <strong>原理图：</strong></p>
<p>   <img src="/2019/07/18/standby/alarm/MessageQueue.png" alt="1562654136209"></p>
<p>   <strong>MessageQueue流程：</strong></p>
<ol>
<li><strong>Looper</strong> 通过<strong>addFd</strong> 添加文件管道监听和事件回调；</li>
<li>当文件监听到消息后，<strong>handler</strong>通过<strong>dispatchMessage</strong>进行消息派发，<strong>Looper-&gt;sendMessage;</strong></li>
<li>收到消息后走到Handler的<strong>handleMessgae</strong>，进行消息处理</li>
</ol>
<h2><span id="同一app内部的不同组件之间的消息通信单个进程">同一app内部的不同组件之间的消息通信（单个进程)</span></h2><p>   <strong>常用方法：EventBus</strong></p>
<p>   <strong>原理图：</strong></p>
<p>   <img src="/2019/07/18/standby/alarm/EventBus.png" alt="1562053083623"></p>
<p>   <strong>EventBus流程：</strong></p>
<p>   还没有接触使用过，暂时不讲，是安卓的一种轻量级的事件通知机制；</p>
<h2><span id="其他">其他</span></h2><ol>
<li><p>同一app具有多个进程的不同组件之间的消息通信</p>
</li>
<li><p>不同app之间的组件之间消息通信</p>
</li>
<li><p>Android 系统在特定情况下与App之间的消息通信</p>
</li>
</ol>
<p>​    <strong>常用方法：PendingIntent</strong></p>
<p>​    <strong>原理图：</strong></p>
<p><em>**</em>        <img src="/2019/07/18/standby/alarm/Brocast_Receive.png" alt="1562056294011"></p>
<p>​        </p>
<p><strong>BroadCast流程：</strong></p>
<ol>
<li>将<strong>Intentfliter</strong>跟<strong>receiver</strong>绑定,可通过<strong>静态方式</strong>：在AndroidManifest.xml 进行配置，也可以<strong>动态方式</strong>，<strong>registerReceiver</strong>；</li>
<li><strong>Brastcast</strong>先打包Intent,然后通过<strong>sendBrocast</strong>,进行广播；</li>
<li><strong>recevier</strong>接受到对应的广播在<strong>onReceive</strong>中走处理流程；</li>
</ol>
<p>闹钟app也是依托这些广播的机制进行运作;以下我们会对闹钟设置与闹钟响应的流程进行简单的介绍；</p>
<h1><span id="deskclock-app"><strong>DeskCl</strong>ock APP</span></h1><p>代码路径：packages/apps/DeskClock</p>
<h2><span id="设置闹钟流程">设置闹钟流程：</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">当用户点击选择相应的闹钟后：</span><br><span class="line">TimePickerDialogFragment.java</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(DialogInterface dialog, <span class="keyword">int</span> which)</span> </span>&#123;</span><br><span class="line">     listener.onTimeSet(TimePickerDialogFragment.<span class="keyword">this</span>,</span><br><span class="line">             timePicker.getCurrentHour(), timePicker.getCurrentMinute());</span><br><span class="line"> &#125;</span><br><span class="line">添加对应闹钟：</span><br><span class="line">src/com/android/deskclock/alarms/AlarmTimeClickHandler.java</span><br><span class="line">	asyncAddAlarm(a)</span><br><span class="line"><span class="comment">// Create and add instance to db</span></span><br><span class="line">	setupAlarmInstance(newAlarm)</span><br><span class="line">这里会做两件重要的事情：</span><br><span class="line">一：Pending获取和闹钟注册,</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmManagerStateChangeScheduler</span> <span class="title">implements</span> <span class="title">StateChangeScheduler</span> &#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleInstanceStateChange</span><span class="params">(Context context, Calendar time,</span></span></span><br><span class="line"><span class="function"><span class="params">            AlarmInstance instance, <span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">        final <span class="keyword">long</span> timeInMillis = time.getTimeInMillis();</span><br><span class="line">        LogUtils.i(<span class="string">"Scheduling state change %d to instance %d at %s (%d)"</span>, newState,</span><br><span class="line">                instance.mId, AlarmUtils.getFormattedTime(context, time), timeInMillis);</span><br><span class="line">        final Intent stateChangeIntent =</span><br><span class="line">                createStateChangeIntent(context, ALARM_MANAGER_TAG, instance, newState);</span><br><span class="line">        <span class="comment">// Treat alarm state change as high priority, use foreground broadcasts</span></span><br><span class="line">        stateChangeIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">        PendingIntent pendingIntent = PendingIntent.getService(context, instance.hashCode(),</span><br><span class="line">                stateChangeIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line"></span><br><span class="line">        final AlarmManager am = (AlarmManager) context.getSystemService(ALARM_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (Utils.isMOrLater()) &#123;</span><br><span class="line">            <span class="comment">// Ensure the alarm fires even if the device is dozing.</span></span><br><span class="line">            am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, timeInMillis, pendingIntent);<span class="comment">//这里就能让闹钟跟pendingIntent进行绑定，闹钟来临时就会广播Intent中的Action</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            am.setExact(AlarmManager.RTC_WAKEUP, timeInMillis, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当createStateChangeIntent的时候，就会将服务与Intent进行绑定</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">createStateChangeIntent</span><span class="params">(Context context, String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">        AlarmInstance instance, Integer state)</span> </span>&#123;</span><br><span class="line"> ...</span><br><span class="line">    Intent intent = AlarmInstance.createIntent(context, AlarmService.class, instance.mId);</span><br><span class="line">    intent.setAction(CHANGE_STATE_ACTION);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">二:updateNextAlarm(context) 将用户时钟更新到数据库中，以便保存闹钟信息；这个时间会被保存到settings里面；这样的好处是重新启动后信息不会丢失；确保闹钟能收到闹钟信息；</span><br></pre></td></tr></table></figure>
<p><strong>pendingIntent</strong>：等待着的Intent获取pendingIntent有以下方法，<strong>getActivity：</strong>（用于启动一个Activity的pendingIntent）; <strong>getBroadcast</strong>(方法从系统取得一个用于向BrocastReceiver的Intent广播的PendingIntent); <strong>getService</strong>(用于启动一个Service的pendingIntent)分别对应着3个行为，跳转到一个activity组件，打开一个广播组件和打开一个服务组件；</p>
<p>如上发起端<strong>DeskClock</strong>通过<strong>PendingIntent.getService</strong>会在到在AMS中得到<strong>PendingIntentRecord</strong>对象，当对应的闹钟事件到来时，<strong>AlarmManagerService</strong>会通过传递的<strong>PendingIntent</strong>对象中的<strong>send</strong>方法发起回调，从而做出执行对应的动作；</p>
<p>通过am的set方法设置后，当闹钟时间来临的时候；就会触发下面的响应流程；</p>
<h2><span id="闹钟响应流程">闹钟响应流程：</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当闹钟来临的时候，就会调到AlarmService的onStartCommand</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> AlarmStateManager.CHANGE_STATE_ACTION:</span><br><span class="line">	AlarmStateManager.handleIntent(<span class="keyword">this</span>, intent);</span><br><span class="line">	startAlarm(instance);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAlarm</span><span class="params">(AlarmInstance instance)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">     AlarmAlertWakeLock.acquireCpuWakeLock(<span class="keyword">this</span>);</span><br><span class="line">     <span class="comment">//当处于后台，此时就会出现我们常见的界面全屏的闹钟提示；</span></span><br><span class="line">     AlarmNotifications.showAlarmNotification(<span class="keyword">this</span>, mCurrentAlarm);</span><br><span class="line">     sendBroadcast(<span class="keyword">new</span> Intent(ALARM_ALERT_ACTION));</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2><span id="注意事项">注意事项：</span></h2><p><strong>一：闹钟响应流程中睡眠</strong></p>
<p><strong>从DeskClock应用行为我们也可以看到在应用写闹钟处理函数的时候，需要进行持锁，尤其在耗时较长的操作中；避免还没有进入处理函数，就因为autoSleep进程没有disable从而进入休眠；</strong>另外对于在休眠过程中需要唤醒系统的应用来说setExactAndAllowWhileIdle，旧版本setExact在系统处于Doze的时候，同样会被忽略；</p>
<p><strong>二：setForeground问题：</strong></p>
<p>当API从25升至28时，会出现前台服务设置异常问题,修复如下：</p>
<p>一：针对<strong>Permission Denial: startForeground</strong> ，AndroidManifest.xml需添加属性</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+    <span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.FOREGROUND_SERVICE"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>二：针对<strong>invalid channel for service notification</strong>，需进行channel创建，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NotificationChannel notificationChannel = <span class="keyword">new</span> NotificationChannel(</span><br><span class="line">                DESKCLOCK_NOTIFICATION_CHANNEL,</span><br><span class="line">                <span class="string">"deskclock"</span>,</span><br><span class="line">                NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line"></span><br><span class="line">NotificationCompat.Builder notification = <span class="keyword">new</span> NotificationCompat.Builder(service,DESKCLOCK_NOTIFICATION_CHANNEL)</span><br><span class="line">    </span><br><span class="line">NotificationManager notificationManager =</span><br><span class="line">       (NotificationManager) service.getSystemService(Service.NOTIFICATION_SERVICE);</span><br><span class="line">        notificationManager.createNotificationChannel(notificationChannel);</span><br></pre></td></tr></table></figure>
<p><strong>三：应用在后台的时候PendingIntent 无法startService，所以上述代码流程闹钟应用在后台是不正常的；</strong></p>
<ol>
<li>android提供了一套JobIntentService的机制，对于响应不是很及时的可以改成这种接口；</li>
<li>可将PendingIntent改写为BrocastRecevicer然后在OnReceive中startForegroundService将service带到前台；前台服务的创建需要注意两个细节，可参考此文档<a href="https://blog.csdn.net/Haienzi/article/details/81268022" target="_blank" rel="noopener">Android8.0使用通知创建前台服务</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一：Pending改成以下形式</span><br><span class="line">PendingIntent pendingIntent = PendingIntent.getBroadcast(context, instance.hashCode(),</span><br><span class="line">                    stateChangeIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">二：在广播中开启服务startForegroundService</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmReceiver</span> <span class="title">extends</span> <span class="title">BroadcastReceiver</span> &#123;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        final <span class="keyword">int</span> alarmState = intent.getIntExtra(AlarmStateManager.ALARM_STATE_EXTRA, <span class="number">-1</span>);</span><br><span class="line">        final <span class="keyword">long</span> instanceId = AlarmInstance.getId(intent.getData());</span><br><span class="line">        Intent in = AlarmInstance.createIntent(context, AlarmService.class, instanceId);</span><br><span class="line">		.....</span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O)</span><br><span class="line">        &#123;</span><br><span class="line">            context.startForegroundService(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            context.startService(in);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">三：在服务中startForeground</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT&gt;=<span class="number">26</span>)&#123;</span><br><span class="line">            setForeground();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="alarmmanager">AlarmManager</span></h1><p><strong>主要代码分布：</strong></p>
<p>core/java/android/app/AlarmManager.java</p>
<p>services/core/java/com/android/server/AlarmManagerService.java</p>
<p>services/core/jni/com_android_server_AlarmManagerService.cpp</p>
<p>安卓是怎么实现对闹钟进行监听和注册，分发的呢？</p>
<h2><span id="闹钟的监听">闹钟的监听</span></h2><p><strong>SystemServer</strong>在<strong>startOtherServices</strong>时，会调用<strong>SystemServiceManager</strong>中的<strong>startService</strong>,此时<strong>AlarmManagerService</strong>中的onStart函数就会被调用;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用native的init</span></span><br><span class="line">    mNativeData = init();</span><br><span class="line">    <span class="comment">//因为内核不会保存时区，所以每次重启都需要重新设置</span></span><br><span class="line">    setTimeZoneImpl(SystemProperties.get(TIMEZONE_PROPERTY));</span><br><span class="line">    <span class="comment">//如果获取到的时间小于固件生成的时间，那么利用ro.build.date.utc的时间去更新内核RTC的时间；</span></span><br><span class="line">    <span class="comment">//没有的话不是则按照系统当前时间即可；这样能保证起来的系统时间是比较新的</span></span><br><span class="line">    setKernelTime(systemBuildTime);</span><br><span class="line">    <span class="comment">//注册闹钟服务，用来接收DATE_CHANGED，更新日历时间</span></span><br><span class="line">    mClockReceiver = mInjector.getClockReceiver(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//监听量灭屏广播，</span></span><br><span class="line">    <span class="keyword">new</span> InteractiveStateReceiver();</span><br><span class="line">    <span class="comment">//监听应用协助重启广播</span></span><br><span class="line">    <span class="keyword">new</span> UninstallReceiver();</span><br><span class="line">    <span class="comment">//启动闹钟线程</span></span><br><span class="line">    AlarmThread waitThread = <span class="keyword">new</span> AlarmThread();</span><br><span class="line">    waitThread.start();</span><br><span class="line">    <span class="comment">//发布相关服务，安卓为了提升通信效率。将service分成binder service和local service</span></span><br><span class="line">    <span class="comment">//(用于本进程通信)对应的获取接口为getLocalService(AlarmManagerInternal.class)</span></span><br><span class="line">    publishLocalService(AlarmManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    <span class="comment">//非本进程接口，(AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE)</span></span><br><span class="line">    publishBinderService(Context.ALARM_SERVICE, mService);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在start初始化的时候，我们主要注意的是init流程里面建立的对alarm事件的监听，以及在AlarmThread里面对闹钟时间的响应；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_server_AlarmManagerService_init</span><span class="params">(JNIEnv*, jobject)</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">    TimerFds fds;</span><br><span class="line">    epollfd = epoll_create(fds.size());</span><br><span class="line">    fds[i] = timerfd_create(android_alarm_to_clockid[i], TFD_NONBLOCK);</span><br><span class="line">    <span class="comment">//wall_clock这里会支持的RTCid,这个rtc可以用来距离启动和休眠时的时间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">clockid_t</span> android_alarm_to_clockid[N_ANDROID_TIMERFDS] = &#123;</span><br><span class="line">    CLOCK_REALTIME_ALARM, <span class="comment">//对应安卓闹钟type:RTC_WAKEUP 常用于应用闹钟；</span></span><br><span class="line">    <span class="comment">// A settable system-wide real-time clock</span></span><br><span class="line">    CLOCK_REALTIME, <span class="comment">//对应安卓闹钟type:RTC</span></span><br><span class="line">    </span><br><span class="line">    CLOCK_BOOTTIME_ALARM, <span class="comment">//ELAPSED_REALTIME_WAKEUP //用于计时器，因为不能随系统时间更改</span></span><br><span class="line">    <span class="comment">//单调递增的时钟，包括休眠时候的时间</span></span><br><span class="line">    CLOCK_BOOTTIME, <span class="comment">//ELAPSED_REALTIME</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//单调递增的时钟，不包括休眠时候的时间,这种没有看到安卓有进行使用</span></span><br><span class="line">    CLOCK_MONOTONIC,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//We also need an extra CLOCK_REALTIME fd which exists specifically to be</span></span><br><span class="line">	<span class="comment">//canceled on RTC changes.</span></span><br><span class="line">    CLOCK_REALTIME,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">简单而言，就是创建了对这几种闹钟类型的监听,但允许设置的时钟类型仅有<span class="number">4</span>种；</span><br><span class="line">然后在waitForAlarm中等待这几类闹钟事件上报,并上报有闹钟时间的类型</span><br><span class="line"><span class="keyword">int</span> AlarmImpl::waitForAlarm()</span><br><span class="line">&#123;</span><br><span class="line"> ....</span><br><span class="line">    <span class="keyword">int</span> nevents = epoll_wait(epollfd, events, N_ANDROID_TIMERFDS, <span class="number">-1</span>);</span><br><span class="line"> 	<span class="comment">//如果闹钟在底层被取消了，返回闹钟事件需要更新，没有的话则返回闹钟的类型；</span></span><br><span class="line">    <span class="keyword">ssize_t</span> err = read(fds[alarm_idx], &amp;unused, <span class="keyword">sizeof</span>(unused));</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="闹钟的注册">闹钟的注册</span></h2><p>接回apk设置alarm流程往下梳理注册流程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apk调用：</span><br><span class="line">setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, timeInMillis, pendingIntent);</span><br><span class="line"></span><br><span class="line">setImpl(type, triggerAtMillis, WINDOW_EXACT, <span class="number">0</span>, FLAG_ALLOW_WHILE_IDLE, operation, null, null, null, null, null);</span><br></pre></td></tr></table></figure>
<p><strong>我们这里主要关注两个参数：flag和type</strong></p>
<p><strong>flag讲解：</strong></p>
<p>flag主要影响的是idle状态是否需要唤醒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.FLAG_STANDALONE = 1；用于标识该alarm不会被加入到其他alarm集合中去；</span><br><span class="line">2.FLAG_WAKE_FROM_IDLE = 2；当系统处于Idle状态仍然能唤醒系统；</span><br><span class="line">3.FLAG_ALLOW_WHILE_IDLE = 4；在idle下alarm仍会被执行，并且不会退出idle状态；</span><br><span class="line">4.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED = 8；与3类似，但运行不受任何约束</span><br></pre></td></tr></table></figure>
<p><strong>TYPE讲解：</strong></p>
<p>应用能设置的类型为:<strong>RTC_WAKEUP,RTC,ELAPSED_REALTIME_WAKEUP,ELAPSED_REALTIME.</strong>这四种；</p>
<p>但是在AlarmManagerService会RTC类型的时间进行转换，convertToElapsed，最终设置的类型转换成ELAPSED_REALTIME类型，所以将闹钟的类型只有<strong>ELAPSED_REALTIME_WAKEUP，ELAPSED_REALTIME</strong>;</p>
<p><img src="/2019/07/18/standby/alarm/Clock设置流程.png" alt="1563011053168"></p>
<p>流程总结：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">set</span>流程里面会权限进行检查，根据是否为系统应用或者白名单里面的应用，对flag进行调整；</span><br><span class="line"><span class="number">2.</span>setImpl </span><br><span class="line">    <span class="number">1.</span>闹钟的时间间隔不得低于<span class="number">5</span>s</span><br><span class="line">	<span class="number">2.</span>convertToElapsed(triggerAtTime, type),将绝对时间转换为相对时间，也即是开机时间</span><br><span class="line">	<span class="number">3.</span>比对窗口时间，如果窗口时间为<span class="number">0</span>，精确执行，小于<span class="number">0</span>，通过当前时间减去触发时间得到一个窗口时间，如果大于<span class="number">0</span>则把最早触发时间+窗口时间为最晚的时间；</span><br><span class="line"><span class="number">3.</span>setImplLocked</span><br><span class="line">	<span class="number">1.</span>removeLocked(operation, directReceiver)</span><br><span class="line">    <span class="number">2.</span>构造一个逻辑闹钟alarm，setImplLocked(a, <span class="literal">false</span>, doValidate)</span><br><span class="line"><span class="number">4.</span>setImplLocked</span><br><span class="line">    <span class="number">1.</span>如果是DeviceIdleController（管理doze模式）设置的闹钟，会被模糊提前；</span><br><span class="line">    <span class="number">2.</span>adjustDeliveryTimeBasedOnBucketLocked </span><br><span class="line">    	androidP对应用进行了分组，</span><br><span class="line">    	<span class="number">1.</span>活跃:用户正在使用；闹钟延迟<span class="number">0</span>min</span><br><span class="line">    	<span class="number">2.</span>工作集：经常在运行，但并未处于活跃状态；延迟<span class="number">6</span>min;</span><br><span class="line">    	<span class="number">3.</span>常用：应用会被定期使用，但不是每天都必须使用；<span class="number">30</span>min;</span><br><span class="line">    	<span class="number">4.</span>极少使用：应用不经常使用；<span class="number">2</span>h;</span><br><span class="line">    	<span class="number">5.</span>从未使用;<span class="number">10</span>d</span><br><span class="line">	<span class="number">3.</span>insertAndBatchAlarmLocked</span><br><span class="line">      <span class="number">1.</span>如果是带有FLAG_STANDALONE标志的，新建一个Batch；</span><br><span class="line">      <span class="number">2.</span>如果不是的话会根据两个闹钟设置的时TriggerTime和最大允许的闹钟发生时间(max triigertime)；两个		之间取交集(narrow batch)作为闹钟触发时间如果找不到则继续新建；</span><br><span class="line">    <span class="number">4.</span>rescheduleKernelAlarmsLocked</span><br><span class="line">    从Batch <span class="built_in">list</span>里面找到近的闹钟，通过timerfd设置到内核；</span><br><span class="line">    <span class="number">5.u</span>pdateNextAlarmClockLocked</span><br><span class="line">  	更新用户下一次的闹钟时间</span><br></pre></td></tr></table></figure>
<p><strong>如图为batch的形成过程：</strong></p>
<p><img src="/2019/07/18/standby/alarm/batch.png" alt="1562911201925"></p>
<h2><span id="闹钟时间分发">闹钟时间分发</span></h2><p>对于时间事件的分发，我们主要看<strong>AlarmThread</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">AlarmThread</span> <span class="title">extends</span> <span class="title">Thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> result = waitForAlarm();</span><br><span class="line">        <span class="keyword">if</span> (WAKEUP_STATS) &#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="comment">//可以记录一天内的闹钟唤醒历史，可以用来统计闹钟优化的程度；</span></span><br><span class="line">            recordWakeupAlarms(mAlarmBatches, nowELAPSED, nowRTC);</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//并获取到点闹钟列表，根据当前是否处于Doze模式或者app standby更新闹钟的响应时间</span></span><br><span class="line">        boolean hasWakeup = triggerAlarmsLocked(triggerList, nowELAPSED);</span><br><span class="line">        <span class="comment">//将获取到的闹钟进行派发</span></span><br><span class="line">        deliverAlarmsLocked(triggerList, nowELAPSED);</span><br><span class="line">        这几个在<span class="built_in">set</span>的时候也会被调用不再赘述</span><br><span class="line">        reorderAlarmsBasedOnStandbyBuckets(triggerPackages);</span><br><span class="line">        rescheduleKernelAlarmsLocked();</span><br><span class="line">        updateNextAlarmClockLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alarm消息的传递流程如下所示，如果设置的时候传入的是PendingIntent则会进入send流程，如果设置的时候传入的是Listener那么就会走到onAlarm的流程；</p>
<p><img src="/2019/07/18/standby/alarm/Alarm事件派发.png" alt="1563105032995"></p>
<h1><span id="内核闹钟流程">内核闹钟流程</span></h1><p>当用户层设置闹钟的时候，内核不会马上设置到RTC寄存器；而是在suspend的时候从队列里面取出最早的时钟，然后设置进去；通过trace我们就能直接看出这种关系来</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">timerfd_settime</span><br><span class="line">do_timerfd_settime</span><br><span class="line">	timerfd_setup</span><br><span class="line">		alarm_start</span><br><span class="line">			alarmtimer_enqueue(base, alarm);</span><br><span class="line">				timerqueue_add(&amp;base-&gt;timerqueue, &amp;alarm-&gt;node);</span><br><span class="line"><span class="number">3</span>)               |  alarm_start() &#123;</span><br><span class="line"><span class="number">3</span>)   <span class="number">2.125</span> us    |    alarmtimer_enqueue();</span><br><span class="line"><span class="number">3</span>) + <span class="number">16.500</span> us   |  &#125;</span><br><span class="line"><span class="number">3</span>)               |  alarm_start() &#123;</span><br><span class="line"><span class="number">3</span>)   <span class="number">3.291</span> us    |    alarmtimer_enqueue();</span><br><span class="line"><span class="number">3</span>) + <span class="number">21.791</span> us   |  &#125;</span><br><span class="line">alarmtimer_suspend() &#123;</span><br><span class="line">  rtc_timer_start() &#123;</span><br><span class="line">    rtc_timer_enqueue() &#123;</span><br><span class="line">      __rtc_set_alarm() &#123;</span><br><span class="line">        sunxi_rtc_setalarm();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1><span id="关机闹钟的实现">关机闹钟的实现</span></h1><p>当梳理完应用到内核的完整路径后，我们就可以借助这套机制完成我们的所要的需求；</p>
<p>这里主要利用的有两点：</p>
<p><strong>一：DeskClock这类的闹钟应用在设置闹钟的时候会把AlarmClockInfo闹钟信息保存在系统中；此时，我们会将闹钟信息保存，当关机的时候再设置到RTC寄存器中；</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNextAlarmInfoForUserLocked</span><span class="params">(<span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">         AlarmManager.AlarmClockInfo alarmClock)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (alarmClock != null) &#123;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">             Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): "</span> +</span><br><span class="line">                     formatNextAlarm(getContext(), alarmClock, userId));</span><br><span class="line">         &#125;</span><br><span class="line">         mNextAlarmClockForUser.put(userId, alarmClock);</span><br><span class="line">     +   mShutdownReceiver.setTime(alarmClock.getTriggerTime()/<span class="number">1000</span> - <span class="number">90</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">             Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): None"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         mNextAlarmClockForUser.remove(userId);</span><br><span class="line">     +   mShutdownReceiver.setTime(<span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mPendingSendNextAlarmClockChangedForUser.put(userId, <span class="literal">true</span>);</span><br><span class="line">     mHandler.removeMessages(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line">     mHandler.sendEmptyMessage(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShutdownReceiver</span> <span class="title">extends</span> <span class="title">BroadcastReceiver</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTime = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ShutdownReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        filter.addAction(Intent.ACTION_SHUTDOWN);</span><br><span class="line">        getContext().registerReceiver(<span class="keyword">this</span>, filter);</span><br><span class="line">        updateNextRtcAlarm(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"AlarmManagerService receive shutting down set rtc alarm time: "</span> + mTime);</span><br><span class="line">        synchronized (mLock) &#123;</span><br><span class="line">            updateNextRtcAlarm(mTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        mTime = time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二：timerfd和epoll_wait，在关机充电的时候，需要判断关机时间到来，当闹钟时间到的时候；我们会重启系统；进入android；</strong></p>
<p><strong>关键代码：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">alarm_thread_handler</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)arg;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">EPOLL_LISTEN_CNT</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now_tv</span> = &#123;</span> <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//等待闹钟事件来临，重启系统</span></span><br><span class="line">        <span class="keyword">int</span> nevents = epoll_wait(epollfd, events,  EPOLL_LISTEN_CNT, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nevents &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            LOG(WARNING) &lt;&lt;  __func__ &lt;&lt;<span class="string">" ++++"</span>&lt;&lt; __LINE__ &lt;&lt; <span class="string">" event:"</span>&lt;&lt; nevents&lt;&lt; <span class="string">"errno: "</span>&lt;&lt; errno &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> wakeups;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (read(wakealarm_fd, &amp;wakeups, <span class="keyword">sizeof</span>(wakeups)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"wakealarm_event: read wakealarm fd failed\n"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        gettimeofday(&amp;now_tv, <span class="literal">NULL</span>);</span><br><span class="line">        LOG(WARNING) &lt;&lt;  __func__ &lt;&lt;<span class="string">" "</span> &lt;&lt; <span class="string">"rebooting"</span> &lt;&lt; <span class="string">"now"</span> &lt;&lt; now_tv.tv_sec &lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">        request_suspend(<span class="literal">false</span>);</span><br><span class="line">        reboot(RB_AUTOBOOT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init_shutdown_alarm</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> alarm_secs, alarm_in_booting = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now_tv</span> = &#123;</span> <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">ts</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">    <span class="comment">//获取闹钟时间</span></span><br><span class="line">    alarm_secs = get_wakealarm_sec();</span><br><span class="line">    <span class="comment">// have alarm irq in booting ?</span></span><br><span class="line">    alarm_in_booting = is_alarm_in_booting();</span><br><span class="line">    gettimeofday(&amp;now_tv, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    LOG(WARNING) &lt;&lt; <span class="string">"alarm_in_booting: "</span>&lt;&lt; alarm_in_booting &lt;&lt; <span class="string">"alarm_secs "</span> &lt;&lt; alarm_secs &lt;&lt; <span class="string">"now"</span> &lt;&lt; now_tv.tv_sec &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">// alarm interval time == 0 and have no alarm irq in booting</span></span><br><span class="line">    <span class="keyword">if</span> (alarm_secs &lt;= <span class="number">0</span> &amp;&amp; (alarm_in_booting != <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (alarm_secs)</span><br><span class="line">        ts.tv_sec = alarm_secs;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ts.tv_sec = (<span class="keyword">long</span>)now_tv.tv_sec + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ts.tv_nsec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerspec</span> <span class="title">spec</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;spec, <span class="number">0</span>, <span class="keyword">sizeof</span>(spec));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;spec.it_value, &amp;ts, <span class="keyword">sizeof</span>(spec.it_value));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//timerfd_init</span></span><br><span class="line">    wakealarm_fd = timerfd_create(CLOCK_REALTIME_ALARM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (wakealarm_fd &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"%s, %d, alarm_fd=%d and exit\n"</span>, __func__, __LINE__, wakealarm_fd);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timerfd_settime(wakealarm_fd, TFD_TIMER_ABSTIME, &amp;spec, <span class="literal">NULL</span>) == <span class="number">-1</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"timerfd_settime failed Error[%d:%s]\n"</span>,errno,strerror(errno));</span><br><span class="line">        close(wakealarm_fd);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;;</span><br><span class="line">      <span class="comment">//epoll_init</span></span><br><span class="line">    epollfd = epoll_create(EPOLL_LISTEN_CNT);</span><br><span class="line">    <span class="keyword">if</span> (epollfd &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ev.events = EPOLLIN | EPOLLWAKEUP;</span><br><span class="line">        <span class="comment">//add wakealarm_fd to epollfd</span></span><br><span class="line">        <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, wakealarm_fd, &amp;ev) == <span class="number">-1</span>) &#123;</span><br><span class="line">            LOGE(<span class="string">"epoll_ctl failed; errno=%d\n"</span>, errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            LOGE(<span class="string">"epoll_create failed; errno=%d\n"</span>, errno);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_create(&amp;tid_alarm, <span class="literal">NULL</span>, alarm_thread_handler, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="其他">其他</span></h1><h2><span id="系统时间设置与rtc时间">系统时间设置与RTC时间</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在启动或者联网的时候，安卓会帮我们将网络时间设置到RTC中，前面的过程我们先跳过直接讲最后的</span><br><span class="line">在framework/base/services/core/jni/com_android_server_AlarmManagerService.cpp中</span><br><span class="line">  1.通过setKernelTimeZone将时区设置到内核 通过getprop persist.sys.timezone 可以获取设置的时区，如无则默认没有0时区</span><br><span class="line">  2.通过setKernelTime更新时间到RTC中</span><br><span class="line">设置的流程如下：</span><br><span class="line">  setKernelTime</span><br><span class="line">	--&gt;setTime</span><br><span class="line">	   setTimeofday设置墙上时间</span><br><span class="line">	   gmtimer_r 将当前时间转换成格林威治时间；</span><br><span class="line">	   ioctl(fd, RTC_SET_TIME, &amp;rtc)将转化后的格林威治时间写入RTC中</span><br><span class="line">所以当我们看cat /proc/driver/rtc时间的时候，就是当前时间与时区计算到的格林时间，</span><br><span class="line">在看这个rtc节点的时候会出现与系统时间差上时区；</span><br></pre></td></tr></table></figure>
<h1><span id="代办">代办</span></h1><p><strong>谷歌闹钟管理优化梳理；</strong></p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.cnblogs.com/smyhvae/p/3959204.html" target="_blank" rel="noopener">Android组件系列–Intent详解</a></p>
<p><a href="https://www.runoob.com/w3cnote/android-tutorial-intent-base.html" target="_blank" rel="noopener">Intent的基本使用</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29929031" target="_blank" rel="noopener">Android消息机制，从java层到Native层剖析</a></p>
<p><a href="http://liuwangshu.cn/application/eventbus/2-eventbus-sourcecode.html" target="_blank" rel="noopener">Android事件总线（二）EventBus3.0源码解析</a></p>
<p><a href="https://www.jianshu.com/p/f348f6d7fe59" target="_blank" rel="noopener">Android BroadcastReceiver使用详解</a></p>
<p><a href="https://developer.android.com/about/versions/oreo/background?hl=zh-cn" target="_blank" rel="noopener">后台执行限制</a></p>
<p><a href="https://www.cnblogs.com/lwbqqyumidi/p/4168017.html" target="_blank" rel="noopener">Android广播机制</a></p>
<p><a href="https://www.itread01.com/content/1549611931.html" target="_blank" rel="noopener">Google出品的序列化神奇Protocol Buffer使用攻略</a></p>
<p><a href="http://gityuan.com/2017/03/12/alarm_manager_service/" target="_blank" rel="noopener">理解AlarmManager机制</a></p>
<p><a href="https://my.oschina.net/youranhongcha/blog/196933" target="_blank" rel="noopener">说说PendingIntent的内部机制</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/display/Vsync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/display/Vsync/" itemprop="url">Vsync流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-18T00:07:09+00:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/display/" itemprop="url" rel="index">
                    <span itemprop="name">display</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="vsync">Vsync</span></h1><p>垂直同步，扫描一帧的同步时间，如屏幕的刷新率为60Hz,那么周期为1/60s,也就是16.66ms一次的时间间隔；</p>
<p>在了解安卓的显示流程的时候，网上一般都会贴个图说是通过VSYNC驱动下的绘制，合成，显示的流程线方式；</p>
<p><img src="/2019/06/18/display/Vsync/pipe.png" alt="1558945552666"></p>
<p>实际上由于app和sf都存在着存在一个相位偏移，<strong>所以并不是安全按照Vsync的时序来完成这些操作的；</strong></p>
<p>那什么是VSYNC呢？为了有最基本的认识，让我们从底层代码开始讲起，借助VSYNC我们也会大致了解和体会到显示相关的代码框架；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">./drivers/video/fbdev/sunxi/disp2/disp/dev_disp.c</span><br><span class="line">在fb_init的时候，我们就会创建这个内核线程；</span><br><span class="line">fb_init</span><br><span class="line">	g_fbi.vsync_task[i] = kthread_create(vsync_thread, (<span class="keyword">void</span>*)i, task_name);</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">vsync_thread</span><span class="params">(<span class="keyword">void</span> *parg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> disp = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)parg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        vsync_proc(disp);</span><br><span class="line">        	--&gt;<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"VSYNC%d=%llu"</span>, disp, ts);</span><br><span class="line">			   envp[<span class="number">0</span>] = buf;</span><br><span class="line">	           envp[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">	           kobject_uevent_env(&amp;g_fbi.dev-&gt;kobj, KOBJ_CHANGE, envp);</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span> (kthread_should_stop())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">在这个线程里面会不断的上报Vsync的信号，然后休眠；那什么时候唤醒呢?</span><br><span class="line"></span><br><span class="line">disp_lcd_enable</span><br><span class="line">	disp_sys_register_irq(lcdp-&gt;irq_no,<span class="number">0</span>,disp_lcd_event_proc,(<span class="keyword">void</span>*)lcd,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">disp_lcd_event_proc</span><br><span class="line">    sync_event_proc</span><br><span class="line">        ret = gdisp.init_para.vsync_event(disp);</span><br><span class="line">        vsync_event</span><br><span class="line">            drv_disp_vsync_event</span><br><span class="line">                wake_up_process(g_fbi.vsync_task[sel]);</span><br><span class="line"></span><br><span class="line">根据irq_no和dts可以获知是注册的TCON的中断,也即对应着屏幕的刷新率；</span><br></pre></td></tr></table></figure>
<p>如果我们使用ftrace抓取workqueue的使用情况的话，就能看到有如下的打印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo workqueue:workqueue_queue_work &gt; /sys/kernel/debug/tracing/set_event</span><br><span class="line">$ cat /sys/kernel/debug/tracing/trace_pipe &gt; out.txt</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/18/display/Vsync/vsync.png" alt="vsync"></p>
<p>对于底层的disp,除了提供VSYNC信号，另外，他还提供了disp_ioctl这套系统调用接口，太多的话就不做阐述，如果后面有哪个接口比较重要再做描述；</p>
<h1><span id="hwc">HWC</span></h1><p>代码目录在hareware/aw/hwc2中</p>
<p>hwc提供了安卓标准的hwc的相关接口实现（<strong>hwc2_function_pointer_t</strong>）；安卓通过HIDL调用到hwc的相关function；然后再通过这些接口实现了对kernel/driver的调用；在hwc中有两个主要的线程,负责监听底层的事件，还有送显；</p>
<p><img src="/2019/06/18/display/Vsync/hwc.png" alt="1558932920872"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">threadResouce/hwc_event_thread.cpp</span><br><span class="line">	eventThreadLoop</span><br><span class="line">		vsyncUeventParse(context, msg);</span><br><span class="line">			callVsync(context, vsync_id, timestamp);</span><br><span class="line">在线程中，如果捕捉到Vsyn的Uevent时间，然后进行回调；</span><br><span class="line"></span><br><span class="line">hwc中callback的注册流程：</span><br><span class="line"><span class="keyword">int32_t</span> hwc_register_callback(<span class="keyword">hwc2_device_t</span>* device, <span class="keyword">int32_t</span> descriptor,</span><br><span class="line">    <span class="keyword">hwc2_callback_data_t</span> callbackData, <span class="keyword">hwc2_function_pointer_t</span> pointer)</span><br><span class="line">    </span><br><span class="line">registerEventCallback(<span class="keyword">int</span> bitMapDisplay, <span class="keyword">int32_t</span> descriptor, <span class="keyword">int</span> zOrder,</span><br><span class="line">    <span class="keyword">hwc2_callback_data_t</span> callback_data, <span class="keyword">hwc2_function_pointer_t</span> pointer)</span><br><span class="line">registerEventCallback(<span class="number">0x3</span>, descriptor, <span class="number">0</span>, callbackData, pointer);</span><br><span class="line"></span><br><span class="line">surfaceflinge会通过HIDL的方式注册这个回调函数，这个我们后面再讲；</span><br></pre></td></tr></table></figure>
<h1><span id="hidl">HIDL</span></h1><p>那么HIDL怎么玩的？</p>
<p><img src="/2019/06/18/display/Vsync/hidl.png" alt="1558945098496"></p>
<p>如上所示就是一个HIDL的玩法；以vsync的callback注册流程为例；</p>
<p><strong>SF_BE：</strong>SurfaceFlinger采用的是前后端设计，与HWC相关的逻辑都会放到SurfaceFlingeBE中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">代码路径：framwwork/nativeservices/surfaceflinger/</span><br><span class="line">SurfaceFlinger.cpp</span><br><span class="line">SurfaceFlinger::init()&#123;</span><br><span class="line">    ...</span><br><span class="line">    mCompositionEngine-&gt;setHwComposer(getFactory().createHWComposer(getBE().mHwcServiceName));</span><br><span class="line">    mCompositionEngine-&gt;getHwComposer().registerCallback(<span class="keyword">this</span>, getBE().mComposerSequenceId);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> SurfaceFlinger::onVsyncReceived(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> hwcDisplayId,</span><br><span class="line">                                     <span class="keyword">int64_t</span> timestamp) &#123;</span><br><span class="line">    ATRACE_NAME(<span class="string">"SF onVsync"</span>);</span><br><span class="line"></span><br><span class="line">    Mutex::<span class="function">Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="comment">// Ignore any vsyncs from a previous hardware composer.</span></span><br><span class="line">    <span class="keyword">if</span> (sequenceId != getBE().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!getHwComposer().onVsync(hwcDisplayId, timestamp)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hwcDisplayId != getHwComposer().getInternalHwcDisplayId()) &#123;</span><br><span class="line">        <span class="comment">// For now, we don't do anything with external display vsyncs.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> periodChanged = <span class="literal">false</span>;</span><br><span class="line">    mScheduler-&gt;addResyncSample(timestamp, &amp;periodChanged);</span><br><span class="line">    <span class="keyword">if</span> (periodChanged) &#123;</span><br><span class="line">        mVsyncModulator.onRefreshRateChangeDetected();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HWC2_Client:</strong>属于surfaceflinge进程，通过Binder和HWC2的HAL Server交互，命名空间是HWC2</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">代码路径：services/surfaceflinger/DisplayHardware/</span><br><span class="line">HWComposer.cpp</span><br><span class="line"><span class="keyword">void</span> HWComposer::registerCallback(HWC2::ComposerCallback* callback,</span><br><span class="line">                                  <span class="keyword">int32_t</span> sequenceId) &#123;</span><br><span class="line">    mHwcDevice-&gt;registerCallback(callback, sequenceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;HWC2::Device&gt; mHwcDevice;</span><br><span class="line"></span><br><span class="line">services/surfaceflinger/DisplayHardware/HWC2.cpp</span><br><span class="line"><span class="keyword">void</span> Device::registerCallback(ComposerCallback* callback, <span class="keyword">int32_t</span> sequenceId) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mRegisteredCallback) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Callback already registered. Ignored extra registration "</span></span><br><span class="line">                <span class="string">"attempt."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mRegisteredCallback = <span class="literal">true</span>;</span><br><span class="line">    sp&lt;ComposerCallbackBridge&gt; callbackBridge(</span><br><span class="line">            <span class="keyword">new</span> ComposerCallbackBridge(callback, sequenceId));</span><br><span class="line">    mComposer-&gt;registerCallback(callbackBridge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerCallbackBridge</span> :</span> <span class="keyword">public</span> Hwc2::IComposerCallback &#123;</span><br><span class="line"> 	Return&lt;<span class="keyword">void</span>&gt; onVsync(Hwc2::Display display, <span class="keyword">int64_t</span> timestamp) override</span><br><span class="line"> 	&#123;</span><br><span class="line">    	 mCallback-&gt;onVsyncReceived(mSequenceId, display, timestamp);</span><br><span class="line">     	<span class="keyword">return</span> Void();</span><br><span class="line"> 	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">services/surfaceflinger/DisplayHardware/ComposerHal.cpp</span><br><span class="line"><span class="keyword">void</span> Composer::registerCallback(<span class="keyword">const</span> sp&lt;IComposerCallback&gt;&amp; callback)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = mClient-&gt;registerCallback(callback);</span><br><span class="line">    <span class="keyword">if</span> (!ret.isOk()) &#123;</span><br><span class="line">        ALOGE(<span class="string">"failed to register IComposerCallback"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>HWC SERVER：</strong></p>
<p>client调用到server中标准的接口</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">代码路径：hardware/interfaces/graphics/composer/<span class="number">2.1</span>/</span><br><span class="line">    </span><br><span class="line">utils/hal/include/composer-hal/<span class="number">2.1</span>/ComposerClient.h</span><br><span class="line">Return&lt;<span class="keyword">void</span>&gt; registerCallback(<span class="keyword">const</span> sp&lt;IComposerCallback&gt;&amp; callback) override &#123;</span><br><span class="line">    <span class="comment">// no locking as we require this function to be called only once</span></span><br><span class="line">    mHalEventCallback = <span class="built_in">std</span>::make_unique&lt;HalEventCallback&gt;(callback, mResources.get());</span><br><span class="line">    mHal-&gt;registerEventCallback(mHalEventCallback.get());</span><br><span class="line">    <span class="keyword">return</span> Void();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">utils/passthrough/include/composer-passthrough/<span class="number">2.1</span>/HwcHal.h</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">registerEventCallback</span><span class="params">(hal::ComposerHal::EventCallback* callback)</span> override </span>&#123;</span><br><span class="line"> 	...</span><br><span class="line"> 	mDispatch.registerCallback(mDevice, HWC2_CALLBACK_VSYNC, <span class="keyword">this</span>,</span><br><span class="line"> 	<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">hwc2_function_pointer_t</span>&gt;(vsyncHook));</span><br><span class="line"> 	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">vsyncHook</span><span class="params">(<span class="keyword">hwc2_callback_data_t</span> callbackData, <span class="keyword">hwc2_display_t</span> display,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int64_t</span> timestamp)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">auto</span> hal = <span class="keyword">static_cast</span>&lt;HwcHalImpl*&gt;(callbackData);</span><br><span class="line">     hal-&gt;mEventCallback-&gt;onVsync(display, timestamp);</span><br><span class="line"> &#125;</span><br><span class="line">mDispatch是个结构体</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	HWC2_PFN_REGISTER_CALLBACK registerCallback;</span><br><span class="line">	...</span><br><span class="line">&#125; mDispatch = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">initDispatch</span><span class="params">(<span class="keyword">hwc2_function_descriptor_t</span> desc, T* outPfn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> pfn = mDevice-&gt;getFunction(mDevice, desc);</span><br><span class="line">    <span class="keyword">if</span> (pfn) &#123;</span><br><span class="line">        *outPfn = <span class="keyword">reinterpret_cast</span>&lt;T&gt;(pfn);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGE(<span class="string">"failed to get hwcomposer2 function %d"</span>, desc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">这里之后我们就可以看到代码是走到各自厂家封装的函数了；</span><br></pre></td></tr></table></figure>
<p><strong>HWC VENDER：</strong></p>
<p>提供hwc2_function_pointer_t的实现；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">代码路径：hardware/aw/hwc2</span><br><span class="line">hwc.cpp</span><br><span class="line"><span class="keyword">hwc2_function_pointer_t</span> hwc_device_getFunction(struct hwc2_device* device,</span><br><span class="line"><span class="keyword">int32_t</span> <span class="comment">/*hwc2_function_descriptor_t*/</span> descriptor)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> HWC2_FUNCTION_REGISTER_CALLBACK:</span><br><span class="line">	<span class="keyword">return</span> asFP&lt;HWC2_PFN_REGISTER_CALLBACK&gt;(</span><br><span class="line">	 hwc_register_callback);</span><br><span class="line">	 &#125;</span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<p>1.安卓提供了一套标准的<strong>hwc2_function_pointer_t</strong>给厂家去实现，然后自己就可以通过HIDL接口进行调用；</p>
<p>2.在Vsync时间来临时，会通过回调调到<strong>SurfaceFlinger</strong>的实现函数<strong>onVsyncReceived</strong>,然后又会通过唤醒DispSync这个线程，通过<strong>postEvent</strong>传递VSYNC事件，然后<strong>MessageQueue</strong>收到这个消息后，就会调用对应的hanlder函数，最终调用到SurfaceFlinger中<strong>onMessageReceiver</strong>处理，这里就会去决策是否要进行合成了；细节后面会讲到，我们现在只需要知道有VSYNC会来的时候会调到SurfaceFlinge的回调就行；</p>
<h1><span id="messagequeue">MessageQueue</span></h1><h2><span id="surfaceflinger启动">surfaceflinger启动</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">system/core/rootdir/init.rc</span><br><span class="line">on boot</span><br><span class="line">	class_start core</span><br><span class="line">	</span><br><span class="line">frameworks/native/services/surfaceflinger/surfaceflinger.rc</span><br><span class="line">service surfaceflinger /system/bin/surfaceflinger</span><br><span class="line"></span><br><span class="line">./services/surfaceflinger/main_surfaceflinger.cpp</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span> </span>&#123;</span><br><span class="line">	startGraphicsAllocatorService();</span><br><span class="line">	ProcessState::self()-&gt;setThreadPoolMaxThreadCount(<span class="number">4</span>);</span><br><span class="line">	sp&lt;ProcessState&gt; ps(ProcessState::self());</span><br><span class="line">	ps-&gt;startThreadPool();<span class="comment">//设定surfaceflinger进程的binder线程池个数上限为4，并启动binder线程池</span></span><br><span class="line">	</span><br><span class="line">	sp&lt;SurfaceFlinger&gt; flinger = surfaceflinger::createSurfaceFlinger();</span><br><span class="line">	setpriority(PRIO_PROCESS, <span class="number">0</span>, PRIORITY_URGENT_DISPLAY);<span class="comment">//设置进程优先级</span></span><br><span class="line">	set_sched_policy(<span class="number">0</span>, SP_FOREGROUND);<span class="comment">//设置为前台进程</span></span><br><span class="line">	</span><br><span class="line">	flinger-&gt;init(); <span class="comment">//初始化</span></span><br><span class="line">	sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">	sm-&gt;addService(String16(SurfaceFlinger::getServiceName()), flinger, <span class="literal">false</span>,</span><br><span class="line">		IServiceManager::DUMP_FLAG_PRIORITY_CRITICAL | IServiceManager::DUMP_FLAG_PROTO);</span><br><span class="line">	sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param)<span class="comment">//设置进程运行策略</span></span><br><span class="line">	</span><br><span class="line">	startDisplayService();</span><br><span class="line">	flinger-&gt;run(); <span class="comment">//实行surfaceflinger中的run方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先将创建的线程给打出来，后面有涉及到的线程作用也会提及</p>
<p><img src="/2019/06/18/display/Vsync/thread.png" alt="1558615784026"></p>
<h2><span id="messagequeue创建">MessageQueue创建</span></h2><p><strong>类介绍</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> <span class="keyword">public</span> BnSurfaceComposer, 实现SurfaceComposer接口</span><br><span class="line">                       <span class="keyword">public</span> PriorityDumper,        <span class="comment">//实现SurfaceFlinger的信息dump</span></span><br><span class="line">                        IBinder::DeathRecipient,</span><br><span class="line">					   <span class="keyword">private</span> HWC2::ComposerCallback 实现以下三种事件回调</span><br><span class="line">					   		<span class="comment">//onHotplugReceived 屏幕热插拔事件</span></span><br><span class="line">					   		<span class="comment">//onRefreshReceived 当图层的配置参数有变动的时候，SurfaceFlinger前面给的数据不能用的时候</span></span><br><span class="line">					   		<span class="comment">//onVsyncReceived 接受底层硬件上报的垂直同步信息</span></span><br></pre></td></tr></table></figure>
<p><strong>onFirstRef</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">flinger的数据类型为sp强指针类型，当首次被强指针引用的时候则执行onFirstRef</span><br><span class="line">onFirstRef</span><br><span class="line">	 mEventQueue-&gt;init(this);</span><br><span class="line">	 </span><br><span class="line">services/surfaceflinger/Scheduler/MessageQueue.cpp	 	</span><br><span class="line">void MessageQueue::init(const sp&lt;SurfaceFlinger&gt;&amp; flinger) &#123;  </span><br><span class="line">	mFlinger = flinger;    </span><br><span class="line">	mLooper = new Looper(true);    </span><br><span class="line">	mHandler = new Handler(*this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/18/display/Vsync/messagequeue.png" alt="img"></p>
<p>简单介绍一下就是looper不断从MessageQueue中取出一个Message,然后交给其对应的Hanlder;handler通过Looper sendMessgae 到队列中，也负责处理相关的消息，处理的消息为INVALIDATE，REFRESH当Vsync来的时候会调到callback,onVsyncReceived；接下来就是消息的收发是怎么驱动起来的了~</p>
<h2><span id="线程创建">线程创建</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::init() &#123;</span><br><span class="line">....</span><br><span class="line"><span class="comment">//创建EventControlThread来控制Vsync的开关， DispSyncThread软件产生的Vsync的线程</span></span><br><span class="line">mScheduler =</span><br><span class="line">        getFactory().createScheduler([<span class="keyword">this</span>](<span class="keyword">bool</span> enabled) &#123; setPrimaryVsyncEnabled(enabled); &#125;,</span><br><span class="line">                                     mRefreshRateConfigs);</span><br><span class="line">   --&gt; make_unique&lt;impl::DispSync&gt;(<span class="string">"SchedulerDispSync"</span>)</span><br><span class="line">       --&gt;<span class="keyword">new</span> DispSyncThread(name, mTraceDetailedInfo);</span><br><span class="line">       --&gt;primaryDispSync-&gt;init</span><br><span class="line">       --&gt;mThread-&gt;run(<span class="string">"DispSync"</span>, PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE);</span><br><span class="line">   --&gt; mEventControlThread = <span class="built_in">std</span>::make_unique&lt;impl::EventControlThread&gt;(function); </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取Vsync周期    </span></span><br><span class="line"><span class="keyword">auto</span> resyncCallback =</span><br><span class="line">        mScheduler-&gt;makeResyncCallback(<span class="built_in">std</span>::bind(&amp;SurfaceFlinger::getVsyncPeriod, <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//SF EventThread该线程用于SurfaceFlinger接受Vsync用于渲染和合成</span></span><br><span class="line">mSfConnectionHandle = mScheduler-&gt;createConnection(<span class="string">"sf"</span>, </span><br><span class="line">          mPhaseOffsets-&gt;getCurrentSfOffset(),resyncCallback, [<span class="keyword">this</span>](<span class="keyword">nsecs_t</span> timestamp) &#123;</span><br><span class="line">                           mInterceptor-&gt;saveVSyncEvent(timestamp);</span><br><span class="line">                      &#125;);</span><br><span class="line">   --&gt;makeEventThread</span><br><span class="line">    --&gt; <span class="built_in">std</span>::make_unique&lt;DispSyncSource&gt;(dispSync, phaseOffsetNs, <span class="literal">true</span>, connectionName);</span><br><span class="line">    	<span class="built_in">std</span>::make_unique&lt;impl::EventThread&gt;(<span class="built_in">std</span>::move(eventThreadSource),</span><br><span class="line">                              <span class="built_in">std</span>::move(interceptCallback), connectionName);              			 --&gt;mThread = <span class="built_in">std</span>::thread([<span class="keyword">this</span>]() NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">    	      <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mMutex);</span><br><span class="line">              threadMain(lock);</span><br><span class="line">&#125;);</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程流程图</strong></p>
<p><img src="/2019/06/18/display/Vsync/SF线程联系.png" alt="img"></p>
<p>对于我们而言需要知道的就是<strong>onVsyncReceive</strong>后会经过<strong>addResyncSample-&gt;updateModel</strong>  来到<strong>DispSyncThread</strong>线程的一直走到<strong>onVsyncEvent</strong>然后走到<strong>mSFEventThread</strong>的<strong>sendEvent</strong>,这个时候我们的MessageQueue就会收到消息，派发INVALID的消息然后决策是否需要刷新；</p>
<p>虽然说系统每秒有60个HW Vsync,但不代表APP和Vsync在每个Vsync都要更新画面，因为在Android里面，是根据software VSYN（Vsync-sf和Vsync-app）来更新画面，Software Vsync根据HwVsync过去发生的时间推测未来发生的时间，因此当APP或SF利用requestNextVsync的时候才会触发Vsync-sf或VSYNC-app;当SW Vsync和硬件Vsync误差无法接受的时候，就会重新打开硬件Vsync，来重新调节SW vsync</p>
<h1><span id="消息处理">消息处理</span></h1><p><strong>INVALIDATE消息：用于处理Layer或者Display属性的变化以及Layer对应的buffer的更新</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Layer或者Display属性的更新通过调用handleMessageTransaction()处理</span><br><span class="line">2.buffer的更新通过调用handleMessageInvalidate()处理</span><br></pre></td></tr></table></figure>
<p>当做完这一步后会去决策是否要进行刷新；</p>
<p>REFRESH消息：表示SurfaceFlinger需要进行一次合成操作（Refresh）,通过handleMessageRefresh()实现；主要有三种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.L</span>ayer属性的变化导致window state发生变化</span><br><span class="line"><span class="number">2.L</span>ayer有新的buffer到来</span><br><span class="line"><span class="number">3</span>，HWC请求进行一次repaint</span><br></pre></td></tr></table></figure>
<p>如果这三种情况之一发生，则置refreshNeeded为true，调用signalRresh发出MessgaeQueue:REFRESH消息</p>
<p>当Vsync信号来之前，Layer或者Display属性的变化会做本地保存，只有当Vsyn信号到来时，SurfaceFlinger才会通过INVALIDATE和REFRESH消息来做统一的合并渲染和输出的处理工作；</p>
<p><img src="/2019/06/18/display/Vsync/onMessageReceive.png" alt="1559196614903"></p>
<p>代码流程如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> SurfaceFlinger::onMessageReceived(<span class="keyword">int32_t</span> what) NO_THREAD_SAFETY_ANALYSIS &#123;</span><br><span class="line">    <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MessageQueue::INVALIDATE: &#123;</span><br><span class="line">                <span class="keyword">if</span> (hwcFrameMissed &amp;&amp; !gpuFrameMissed) &#123;</span><br><span class="line">                    signalLayerUpdate();</span><br><span class="line">                    	--&gt;connection-&gt;resyncCallback();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">      			handleMessageTransaction（）</span><br><span class="line">                handleMessageInvalidate()</span><br><span class="line">                   --&gt;handlePageFlip(); </span><br><span class="line">                   <span class="comment">//从bufferqueue中取出下一个图形缓冲区，就好像翻页一样;</span></span><br><span class="line">	           <span class="comment">//该函数主要是从各个layer对应的BufferQueue中拿图形缓冲区资料，并根据内容更新脏数据</span></span><br><span class="line">                    --&gt;invalidateLayerStack</span><br><span class="line">                    --&gt;signalRefresh     </span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> MessageQueue::REFRESH: &#123;</span><br><span class="line">                handleMessageRefresh();</span><br><span class="line">           </span><br><span class="line">  	         rebuildLayerStacks();</span><br><span class="line">               <span class="comment">//遍历所有layer按照Z序找到可见图层和可见区域。核心算法有region类完成。</span></span><br><span class="line">               <span class="comment">//它拥有一个私有成员变量mStorage(Vector&lt;Rect&gt;类型)，并封装了与，或，异或操作函数，管			    </span></span><br><span class="line">               <span class="comment">//理一组合法有序的矩形区域。</span></span><br><span class="line">               <span class="comment">//通过region可以方便的计算出多个图层叠加后的可见图层，可见区域及其大小位置</span></span><br><span class="line">               </span><br><span class="line">                   calculateWorkingSet();</span><br><span class="line">               <span class="comment">//遍历所有可见图层，在hal创建影子图层参数，例如hal没有该图层即调用createLayer创建，然				  </span></span><br><span class="line">              <span class="comment">//后分配合成策略,决策由GPU还是DE合成；</span></span><br><span class="line">                   prepareFrame(display);</span><br><span class="line">               <span class="comment">//通过调用hwc validate函数，会调用hwc中的AssignLayer函数，根据厂商的DE情况，决策是				  </span></span><br><span class="line">              <span class="comment">//否是DE合成还是GPU</span></span><br><span class="line">                  doComposition(display, repaintEverything);</span><br><span class="line">              <span class="comment">//合成，如果GPU合成则调用OpenGLES合成到FB,否则全部可见图层参数送到DE，即调用hal的			       </span></span><br><span class="line">              <span class="comment">//hwc_presentDisplay函数，调用presentDisplay获取fence； submitLayerToDisplay将显示</span></span><br><span class="line">              <span class="comment">//Layer加到链表中然后唤醒hwc_submit_thread,</span></span><br><span class="line">              <span class="comment">//调用setupLayer设置好送显的图层参数，再等待生成者的fence释放完成后；</span></span><br><span class="line">              <span class="comment">//调用commitToDisplay送显，最后displayToSrceen调用ioctl完成</span></span><br><span class="line">                </span><br><span class="line">                   postComposition();</span><br><span class="line">                <span class="comment">//完成合成后的一些状态处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="总结">总结</span></h1><p>以下是一帧的大概显示流程,后续有机会在详细讲下技术细节：</p>
<p>​    事件驱动：vsync-app驱动应用层绘图完毕后会回调onFrameAvaliable到SF的layer里面更新layer状态，然后调用requestVsync把mSFEventThread唤醒（应用若长期不送帧，会进入休眠状态），在下一个Vsync信号来时会往MessageQueue(MQ)队列添加invalidata消息。MQ是SF的主线程，它主要处理invalidate和refresh消息。当MQ收到Refresh消息后，就会真正的进入合成和送显的流程；关键流程就是以上所说的<strong>rebuildLayerStacks, calculateWorkingSet, prepareFrame, doComposition, postComposition</strong></p>
<p>​    SF进行Refresh时，通过VrModeSwitch()判断是否处于虚拟桌面，调用prepareFrame(对应HWC的de2TryToAssignLayer)询问HWC各个图层的合成方式。</p>
<p>​    接着调用drawMesh()进行重绘合成（OPENGL）和调用postFrameBuffer()提交合成的画布或这一帧。SF提交是不代表GPU已经处理完成，所以不直接送显；而是通过submitLayerToDisplay()把这一帧放入链表中，就直接返回接着处理下一帧。</p>
<p>​    HWC::DisplayOpr有一个线程，submitThreadLoop()循环通过从链表中拿出一帧数据，通过commitToDisplay()异步向display下发，下发前等GPU完成即fence释放；</p>
<h1><span id="其他">其他</span></h1><p>如何强制GPU合成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service call SurfaceFlinger 1008 i32 1</span><br><span class="line"></span><br><span class="line">确认是否生效：</span><br><span class="line">venus-a1:/ # dumpsys SurfaceFlinger | grep &quot;h/w composer&quot;</span><br><span class="line">h/w composer state:</span><br><span class="line">  h/w composer disable</span><br></pre></td></tr></table></figure>
<p>配置关闭硬件VSYNC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">方案目录的mk文件中添加如下：</span><br><span class="line">TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK := true</span><br></pre></td></tr></table></figure>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.jianshu.com/p/8656bebc27cb" target="_blank" rel="noopener">Android消息机制（一）：概述设计架构</a></p>
<p><a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">Android P 图形显示系统（一）硬件合成HWC2</a></p>
<p><a href="https://www.twblogs.net/a/5c1f1a11bd9eee16b3da61e8" target="_blank" rel="noopener">android 8.0 Hwcomposer2 HIDL流程</a></p>
<p><a href="https://blog.csdn.net/xiaosayidao/article/details/75577940" target="_blank" rel="noopener">Android OTreble架构-HIDL源代码分析</a></p>
<p><a href="[http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81%E4%B8%80-%E5%90%88%E6%88%90Layer%E4%B9%8B%E5%87%86%E5%A4%87%E5%90%88%E6%88%90/](http://windrunnerlihuan.com/2017/12/01/Android-SurfaceFlinger-学习之路-十一-合成Layer之准备合成/">Android SurfaceFlinger学习之路（十一）合成layer之准备合成</a>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/opengl/openg1_1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/opengl/openg1_1/" itemprop="url">opengl学习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-13T00:07:09+00:00">
                2019-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/opengl/" itemprop="url" rel="index">
                    <span itemprop="name">opengl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="opengl流程">opengl流程</span></h1><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口确实2D像素组，这导致OpenGL大部分的工作都是关于把3D坐标转变为适应屏幕的2D像素；3D转成2D坐标的处理过程是OpenGl的图形渲染管线（Graphic Pipeline,大多译为管线，实际上指的是一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的；图形渲染管线可以划分为两个主要部分，第一部分把你3D的坐标转换成2D坐标；第二部分是把2D坐标转变成实际的有颜色的像素；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2D坐标和像素不同，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到屏幕/窗口分辨率的限制</span><br></pre></td></tr></table></figure>
<p>openGL首先接收用户提供的几何数据（顶点和几何图元），并且将它输入到一系列着色器阶段中进行处理，包括：顶点着色（vertex shader ），细分着色，以及最后的几何着色，然后被送入光栅化单元（resterizer）光栅化单元负责对所有剪切区域（clipping region）内的图元生成片元数据，然后对每个生成的片元都执行一个片元着色器；</p>
<p><img src="/2019/05/13/opengl/openg1_1/render_pipeline.png" alt="1561280730893"></p>
<p>下面有个更清晰容易理解的图~</p>
<p><img src="/2019/05/13/opengl/openg1_1/pipe_line图示.png" alt=""></p>
<p><strong>顶点着色器（Vertex Shader</strong>）,它把一个单独的顶点（Vertex）作为输入，顶点着色器主要的目的是把3D坐标转为另一种3D坐标,同时顶点着色器允许我们对顶点属性进行一些基本处理；<strong>如：顶点变换，法向量变化和单位化，生成相应的纹理坐标，纹理坐标变换，雾坐标，光照计算；</strong> 当需要计算顶点在屏幕上的位置，就会涉及到<strong>矩阵变换</strong></p>
<p><strong>图元装配（Primitive Assembly</strong>）阶段将顶点着色器输出的所有顶点作为输入（r如果是GL_POINTS,那么就是一个顶点），并所有的点装配成指定的图形，如上图就是一个三角形；</p>
<p><strong>几何着色器（Geometry Shader）</strong>几何图形把图元形式的一系列顶点的集合作为输入，它可以通过产生新的顶点构造出新的图元来生成其他形状；<strong>这个着色阶段是可选</strong></p>
<p>之后就会传入<strong>光栅化阶段（Rasterization Stage</strong>）,这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器（Fragment Shader）使用的片段（Fragment）.在这之前还会线做下<strong>裁切（Cliping）</strong>会丢弃超出视图以外的所有像素，用来提升效率；</p>
<p><strong>片段着色器</strong>的主要目的是计算一个像素的最终颜色，这也是OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照，阴影，光的颜色等等），这些数据可以用来计算最终像素的颜色；片元着色器的作用有：<strong>雾；提取纹理单元，用于纹理贴图；颜色混合</strong>，等</p>
<p>最后的测试和混合简单而言是根据Zorder和Alpha值进行的图形合成过程；</p>
<p>先有个大概流程的印像，接下来我们会通过一些例子慢慢将流程梳理清楚；先从opengl的基本库开始讲起；</p>
<h1><span id="opengl相关库">Opengl相关库</span></h1><p>opengl基本函数库用来描述图元（graphics output promitive），属性（attribute），几何变换(geometric transformation)，观察变换（viewing transform）和进行其他的操作；由于OpenGl被设计成硬件无关型，因此输入和输出函数等许多操作均不包括在其基础库中；而是放在OpenGl开发的辅助库中；</p>
<p><strong>Opengl基本库(也称OpenGL核心库)：</strong>常见有gl开头的这些函数的写法glBegin, glClear, glCopyPixels, glPolygonMode；变量中GL_2D,GL_RGB,GL_CCW;GL_POLYGON,GL_AMBIENT_AND_DIFFUSE;</p>
<p><strong>相关库：</strong>OpenGL实用函数（openGL Utility,GLU）提供了一些例程，<strong>可以设置观察和投影矩阵，利用线条和多边形近似法来描述复杂对象</strong>，使用线性近似法显示二次曲线和样条曲线，处理表面绘制操作，以及完成其他复杂任务。每一个OpenGL实现中都包括了<strong>GLU库，所有的函数名都用glu开头</strong>。窗口显示系统，opengl实用函数工具包（OpenGL Utility Toolkit,GLUT）<strong>提供了与任意屏幕窗口系统进行交互的函数库</strong>。<strong>GLUT库函数以glut为前缀</strong>，该库也包含了描述与绘制二次和样条曲线及曲面的方法；</p>
<p>说这么多，先来个demo~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/GLUT.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glClearColor(<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>);<span class="comment">//使用RGB颜色值将显示窗口的背景颜色设定为白色，参数解析前面为RGB,最后为alpha值</span></span><br><span class="line"></span><br><span class="line">	glMatrixMode(GL_PROJECTION);<span class="comment">//设置投影矩阵，</span></span><br><span class="line">	gluOrtho2D(<span class="number">0.0</span>, <span class="number">200.0</span>, <span class="number">0.0</span>, <span class="number">150.0</span>);<span class="comment">//正交投影见过世界坐标系二维矩阵区域的内容映射到屏幕上，区域的x的坐标值从0.0到200，y坐标从0到150.只要再该矩形内定义的对象，都会出现在显示窗口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lineSegment</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT);<span class="comment">//用来指定它是颜色缓存中的位值</span></span><br><span class="line"></span><br><span class="line">	glColor3f(<span class="number">0.0</span>, <span class="number">0.4</span>, <span class="number">0.2</span>);<span class="comment">//设置线段的颜色</span></span><br><span class="line">	glBegin(GL_LINES);</span><br><span class="line">		glVertex2i(<span class="number">180</span>, <span class="number">15</span>);</span><br><span class="line">		glVertex2i(<span class="number">10</span>, <span class="number">145</span>);</span><br><span class="line">	glEnd();</span><br><span class="line"></span><br><span class="line">	glFlush();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	glutInit(&amp;argc, argv); <span class="comment">//初始化glut.该函数也能处理命令行参数</span></span><br><span class="line">	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); <span class="comment">//指定显示窗口使用单个缓存和用RGB的颜色模型旋转颜色</span></span><br><span class="line">	glutInitWindowPosition(<span class="number">50</span>, <span class="number">100</span>);<span class="comment">//窗口显示的地方在在显示器的左上角向右50，向下100像素开始显示</span></span><br><span class="line">	glutInitWindowSize(<span class="number">400</span>, <span class="number">300</span>);<span class="comment">//设定显示窗口的初始宽度和高度的像素数</span></span><br><span class="line">	glutCreateWindow(<span class="string">"An Example"</span>); <span class="comment">//窗口创建的时候给个标题</span></span><br><span class="line">	init();</span><br><span class="line">	glutDisplayFunc(lineSegment);<span class="comment">//显示lineSegment线段</span></span><br><span class="line">	glutMainLoop();<span class="comment">//激活已创建的窗口和图形显示的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显示效果如下：</p>
<p><img src="/2019/05/13/opengl/openg1_1/demo.png" alt="demo"></p>
<p>通过这个demo我们大致了解到opengl的大致使用步骤</p>
<ol>
<li>初始化物体渲染所对应的状态。</li>
<li>设置需要渲染的物体</li>
</ol>
<p>接着demo下面我们引入几个概念：</p>
<h1><span id="mvp">MVP</span></h1><p>demo中的init函数中glMatrixMode(GL_PROJECTION);//设置投影矩阵，这个涉及到了投影矩阵，对于opengl常见的就是要进行矩阵变换；我们这里稍微带下</p>
<p><img src="/2019/05/13/opengl/openg1_1/矩阵变换.png" alt="矩阵变换"></p>
<ol>
<li>红色坐标系位模型坐标系，指定了模型各个点的位置，每个点是(x,y,z)组成的数组；由于后面的矩阵都是4*4，所以在后面补上1；</li>
<li>模型变换，将模型坐标转化成世界坐标，把物体在世界坐标系的位置拆分成旋转，平移，缩放的表达式；</li>
<li>视图变换：指定一个相机的位置和角度，然后去观察世界坐标系下的物体；</li>
<li>投影变换：把前面三位空间的坐标系投影到二维屏幕的坐标系，除了屏幕的横纵坐标，另外一个维度就是垂直屏幕方向的坐标，就是之后可以写入深度缓冲区的值。将三维坐标转换到二维屏幕，主要分为正交投影和透视投影，都是用相似三角形算比例；</li>
<li>视口变换，这里只是一个非常简单的XoY平面上的缩放；它决定了最终渲染到平面的哪一块，所以用之前的缩放同样的处理就能得到相应矩阵；这里相当于我们经常在ui中遇到的缩放因子；</li>
</ol>
<p>于是乎：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变换后的坐标=视口矩阵 * 投影矩阵（P） * 视图矩阵(V) * 模型矩阵(M) * 模型点坐标</span><br></pre></td></tr></table></figure>
<p>对应的VR里面左右眼的矩阵模型公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">leftEyeMvp = projectMatrix*projRot(投影矩阵) * mHeadOrient*mleftEye（视口矩阵） * mode（模型点）</span><br></pre></td></tr></table></figure>
<p>通过这个矩阵我们就能从三维空间映射到我们的屏幕上，由于左右眼的视口矩阵不同产生的视觉差，让我们又产生了3d的效果；</p>
<p>这里有两个工具可以更好的理解这一概念：</p>
<p><strong>MODELVIEW</strong></p>
<p><a href="http://www.songho.ca/opengl/files/matrixModelView.zip" target="_blank" rel="noopener">http://www.songho.ca/opengl/files/matrixModelView.zip</a></p>
<p><strong>PROJECTION</strong></p>
<p><a href="http://www.songho.ca/opengl/files/matrixProjection.zip" target="_blank" rel="noopener">http://www.songho.ca/opengl/files/matrixProjection.zip</a></p>
<p>知道了矩阵变换后；我们还会经常遇到着色器这个名字；那这个是什么呢？</p>
<h1><span id="着色器">着色器</span></h1><p>着色器（Shader）是运行在GPU上的小程序，这些小程序为图形渲染管线的某个特定部分而运行；在openGL中着色器就相当于画笔，而顶点vertices相当于图形（把一个个点按顺序用线连接起来就是一个图形），着色器OpenGL分成两个部分，一个用于绘制顶点的顶点着色器VerticesShader，一个用于顶点连线后所包围的区域填充颜色的片元着色器，可以理解为windows画图中的填充工具；</p>
<p><img src="/2019/05/13/opengl/openg1_1/shader.png" alt="1560837291736"></p>
<p>我们常见的着色器普遍认为有三种，在移动设备上使用较多的OpenGL的<strong>GLSL</strong>,在桌面使用较多微软推的DirectX的<strong>HSLS(High level shader language)</strong>;还有NVIDIA公司的<strong>CG（C for Graphic）</strong>；谷歌后面会推的Vulkan，着色器语言是基于GLSL为基础进行增强；由于本文基于的是OpenGL所以就是用的GLSL;</p>
<p>语言总是苍白的，来段代码吧~~</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glew.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> g_lightPos[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">changeSize</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Prevent a divide by zero, when window is too short</span></span><br><span class="line">	<span class="comment">// (you cant make a window of zero width).</span></span><br><span class="line">	<span class="keyword">if</span>(h == <span class="number">0</span>)</span><br><span class="line">		h = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> ratio = <span class="number">1.0</span>* w / h;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reset the coordinate system before modifying</span></span><br><span class="line">	glMatrixMode(GL_PROJECTION);</span><br><span class="line">	glLoadIdentity();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Set the viewport to be the entire window</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set the correct perspective.</span></span><br><span class="line">	gluPerspective(<span class="number">45</span>,ratio,<span class="number">1</span>,<span class="number">1000</span>);</span><br><span class="line">	glMatrixMode(GL_MODELVIEW);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">renderScene</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">	glLoadIdentity();</span><br><span class="line">	gluLookAt(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">5.0</span>,<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">-1.0</span>,<span class="number">0.0f</span>,<span class="number">1.0f</span>,<span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">	glLightfv(GL_LIGHT0, GL_POSITION, g_lightPos);</span><br><span class="line">	glutSolidTeapot(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	glutSwapBuffers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processNormalKeys</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> key, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (key == <span class="number">27</span>) </span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">readShaderSource</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line">	<span class="keyword">char</span> *content = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fileName != <span class="literal">NULL</span>) </span><br><span class="line">	&#123;</span><br><span class="line">		fp = fopen(fileName,<span class="string">"rt"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fp != <span class="literal">NULL</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			fseek(fp, <span class="number">0</span>, SEEK_END);</span><br><span class="line">			count = ftell(fp);</span><br><span class="line">			rewind(fp);</span><br><span class="line">			<span class="keyword">if</span> (count &gt; <span class="number">0</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				content = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (count+<span class="number">1</span>));</span><br><span class="line">				count = fread(content,<span class="keyword">sizeof</span>(<span class="keyword">char</span>),count,fp);</span><br><span class="line">				content[count] = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			fclose(fp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">genShader</span><span class="params">(GLenum type,<span class="keyword">const</span> <span class="keyword">char</span>* fileName,<span class="keyword">char</span>*&amp; <span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建着色器对象</span></span><br><span class="line">	GLuint shader = glCreateShader(type);</span><br><span class="line">	<span class="comment">//从文件中读取着色器的实现代码</span></span><br><span class="line">	<span class="keyword">char</span>* shaderSource = readShaderSource(fileName);</span><br><span class="line">	<span class="keyword">if</span>( !shaderSource )</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* ptrShaderSource = shaderSource;</span><br><span class="line">	<span class="comment">//将着色器的实现代码与创建的着色器对象绑定</span></span><br><span class="line">	glShaderSource(shader,<span class="number">1</span>,&amp;ptrShaderSource,<span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">free</span>(shaderSource);</span><br><span class="line">	<span class="comment">//编译着色器对象</span></span><br><span class="line">	glCompileShader(shader);</span><br><span class="line">	GLint status = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//查看编译状态</span></span><br><span class="line">	glGetShaderiv(shader,GL_COMPILE_STATUS,&amp;status);</span><br><span class="line">	<span class="keyword">if</span>( !status )</span><br><span class="line">	&#123;</span><br><span class="line">		GLint length;</span><br><span class="line">		<span class="comment">//读取日志信息的长度</span></span><br><span class="line">		glGetShaderiv(shader,GL_INFO_LOG_LENGTH,&amp;length);</span><br><span class="line">		<span class="built_in">log</span> = (GLchar*)<span class="built_in">malloc</span>(length);</span><br><span class="line">		<span class="comment">//读取日志信息</span></span><br><span class="line">		glGetShaderInfoLog(shader,length,&amp;length,<span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">//删除着色器对象</span></span><br><span class="line">		glDeleteShader(shader);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> shader;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">GLuint <span class="title">linkProgram</span><span class="params">(GLuint* shader,<span class="keyword">int</span> shaderNum,<span class="keyword">char</span>*&amp; <span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//创建着色器程序</span></span><br><span class="line">	GLuint program = glCreateProgram();</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="comment">//往着色器程序中加入着色器对象</span></span><br><span class="line">	<span class="keyword">for</span>( i=<span class="number">0</span> ; i&lt;shaderNum ; i++ )</span><br><span class="line">		glAttachShader(program,shader[i]);</span><br><span class="line">	<span class="comment">//链接着色器程序</span></span><br><span class="line">	glLinkProgram(program);</span><br><span class="line">	GLint status;</span><br><span class="line">	<span class="comment">//查看链接状态</span></span><br><span class="line">	glGetProgramiv(program,GL_LINK_STATUS,&amp;status);</span><br><span class="line">	<span class="keyword">if</span>( !status )</span><br><span class="line">	&#123;</span><br><span class="line">		GLint length;</span><br><span class="line">		<span class="comment">//读取日志信息的长度</span></span><br><span class="line">		glGetProgramiv(program,GL_INFO_LOG_LENGTH,&amp;length);</span><br><span class="line">		<span class="built_in">log</span> = (GLchar*)<span class="built_in">malloc</span>(length);</span><br><span class="line">		<span class="comment">//读取日志信息</span></span><br><span class="line">		glGetProgramInfoLog(program,length,&amp;length,<span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>,<span class="built_in">log</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		<span class="comment">//删除着色器对象</span></span><br><span class="line">		glDeleteProgram(program);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> program;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useProgram</span><span class="params">(GLuint program)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//运行创建成功的着色器程序</span></span><br><span class="line">	glUseProgram(program);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">setShaders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* <span class="built_in">log</span> = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">//创建一个顶点着色器对象</span></span><br><span class="line">	GLuint vertexShader = genShader(GL_VERTEX_SHADER,<span class="string">"toon.vert"</span>,<span class="built_in">log</span>);</span><br><span class="line">	<span class="keyword">if</span>( !vertexShader )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">log</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//创建一个片断着色器对象</span></span><br><span class="line">	GLuint fragmentShader = genShader(GL_FRAGMENT_SHADER,<span class="string">"toon.frag"</span>,<span class="built_in">log</span>);</span><br><span class="line">	<span class="keyword">if</span>( !fragmentShader )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">log</span>);</span><br><span class="line">		glDeleteShader(vertexShader);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把创建好的顶点和片断着色器对象链接到着色器程序中</span></span><br><span class="line">	GLuint shader[<span class="number">2</span>] = &#123;vertexShader,fragmentShader&#125;;</span><br><span class="line">	GLuint program = linkProgram(shader,<span class="number">2</span>,<span class="built_in">log</span>);</span><br><span class="line">	<span class="keyword">if</span>( !program )</span><br><span class="line">	&#123;</span><br><span class="line">		glDeleteShader(vertexShader);</span><br><span class="line">		glDeleteShader(fragmentShader);</span><br><span class="line">		<span class="built_in">free</span>(<span class="built_in">log</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//使用创建成功的着色器程序</span></span><br><span class="line">	useProgram(program);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	glutInit(&amp;argc, argv);</span><br><span class="line">	glutInitDisplayMode(GLUT_DEPTH | GLUT_DOUBLE | GLUT_RGBA);</span><br><span class="line">	glutInitWindowPosition(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">	glutInitWindowSize(<span class="number">320</span>,<span class="number">320</span>);</span><br><span class="line">	glutCreateWindow(<span class="string">"Shader-Demo"</span>);</span><br><span class="line"></span><br><span class="line">	glutDisplayFunc(renderScene);</span><br><span class="line">	glutReshapeFunc(changeSize);</span><br><span class="line">	glutKeyboardFunc(processNormalKeys);</span><br><span class="line"></span><br><span class="line">	glEnable(GL_DEPTH_TEST);</span><br><span class="line">	glClearColor(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	glewInit();</span><br><span class="line">	<span class="comment">//判断是否支持GLSL</span></span><br><span class="line">	<span class="keyword">if</span> (GLEW_ARB_vertex_shader &amp;&amp; GLEW_ARB_fragment_shader)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Ready for GLSL\n"</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"No GLSL support\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	setShaders();</span><br><span class="line">	glutMainLoop();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2><span id="顶点着色器">顶点着色器</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">varying vec3 normal, lightDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	lightDir = normalize(vec3(gl_LightSource[<span class="number">0</span>].position));</span><br><span class="line">	normal = normalize(gl_NormalMatrix * gl_Normal);</span><br><span class="line">		</span><br><span class="line">	gl_Position = ftransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们讨论到顶点着色器的时候，每个输入变量也叫顶点属性（Vertex Attribute）。我们能声明的顶点属性是有上限的</p>
<h2><span id="片源着色器">片源着色器</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">varying vec3 normal, lightDir;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> intensity;</span><br><span class="line">	vec3 n;</span><br><span class="line">	vec4 color;</span><br><span class="line"></span><br><span class="line">	n = normalize(normal);</span><br><span class="line">	intensity = max(dot(lightDir,n),<span class="number">0.0</span>); </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (intensity &gt; <span class="number">0.98</span>)</span><br><span class="line">		color = vec4(<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (intensity &gt; <span class="number">0.5</span>)</span><br><span class="line">		color = vec4(<span class="number">0.4</span>,<span class="number">0.4</span>,<span class="number">0.8</span>,<span class="number">1.0</span>);	</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (intensity &gt; <span class="number">0.25</span>)</span><br><span class="line">		color = vec4(<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.4</span>,<span class="number">1.0</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		color = vec4(<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">1.0</span>);		</span><br><span class="line">		</span><br><span class="line">	gl_FragColor = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   <strong>效果图如下所示：</strong></p>
<p><img src="/2019/05/13/opengl/openg1_1/shader_demo.png" alt="1561355152918"></p>
<h2><span id="总结">总结</span></h2><p>着色器的创建流程 <strong>genShader</strong>：</p>
<ol>
<li>创建一个着色器对象 <strong>glCreateShader</strong>；</li>
<li>将着色器的实现代码与创建的着色器对象绑定 <strong>glShaderSource</strong>;</li>
<li>把着色器源代码编译为目标代码 <strong>glCompileShader</strong>；</li>
<li>验证是否编译通过 <strong>glGetShaderiv</strong>；</li>
</ol>
<p>接着，把创建好的着色器加入到着色程序中</p>
<ol>
<li>创建一个着色程序 <strong>glCreateProgram</strong>;</li>
<li>把适当的着色对象连接到这个着色程序中 <strong>glAttachShader</strong>；</li>
<li>链接到这个着色器程序 <strong>glLinkProgram</strong>；</li>
<li>验证这着色器结点已经成功完成 <strong>glGetProgramiv</strong>；</li>
<li>使用着色器进行顶点或者片元处理 <strong>useProgram</strong>；</li>
</ol>
<p>对于安卓来讲，会把这些接口都进行封装，简化使用；</p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="http://zhangwenli.com/blog/2015/08/28/opengl-matrix-transformations/" target="_blank" rel="noopener">搞懂矩阵运算</a></p>
<p><a href="http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-3-matrices/#%E7%B4%AF%E7%A7%AF%E5%8F%98%E6%8D%A2" target="_blank" rel="noopener">第三课：矩阵</a></p>
<p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/01%20Getting%20started/05%20Shaders/" target="_blank" rel="noopener">着色器</a></p>
<p><a href="https://www.jianshu.com/p/68ee05d6106a" target="_blank" rel="noopener">openGL ES学习之着色器语言</a></p>
<p><a href="https://www.jianshu.com/p/ce20f98e20cf" target="_blank" rel="noopener">Android OpenGL ES从白痴到入门</a></p>
<p><a href="https://blog.csdn.net/lyx2007825/article/details/8792475" target="_blank" rel="noopener">openGl 矩阵变换</a></p>
<p><a href="http://www.twinklingstar.cn/2013/793/basic-shader/" target="_blank" rel="noopener">openGL着色器介绍</a></p>
<p><a href="https://blog.csdn.net/jxt1234and2010/article/details/53440644" target="_blank" rel="noopener">OpenGL替代者-Vulkan</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU0ODE1NDE0NQ==&amp;mid=2247524191&amp;idx=1&amp;sn=2a851fc5d146edc8f4ba46dbc039bd4a&amp;chksm=fb41a111cc362807399a9fa8f1663e3df81e3e93518861da9e6296888df83b87257190db6cfd&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;key=ab45025d723271920e5e7ceef2a9ff96508f755ae36ab1b9330852f71e41819720da88eecf0ee779b0dd170445ecad71d719642eaa88850b4922a7f38b4185529549b4e4a841e4e4fda560e3d975e9d2&amp;ascene=1&amp;uin=MTkyMDU3MjE0MQ%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=%2BPax7dvNed53rjvvLVZae0UUuqun3ie29KvXg7y2zh0MPYnAnkQy8uIjADaL0cHi" target="_blank" rel="noopener">是立体还是平面</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/27/display/休眠唤醒cma内存泄漏/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/display/休眠唤醒cma内存泄漏/" itemprop="url">休眠唤醒cma内存泄漏</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-04-27T21:00:00+00:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/display/" itemprop="url" rel="index">
                    <span itemprop="name">display</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="现象分析">现象分析</span></h1><h2><span id="现场排查">现场排查</span></h2><p>起因keeptesting休眠唤醒出现vmap allocation申请内存失败，log打印如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[ 7499.814118] [ion_debug]In ion_buffer_destroy: release buf size 249856, phys_addr 70bc0000, process[1947:composer@2.1-se]</span><br><span class="line">[ 7499.899841] vmap allocation for size 5537792 failed: use vmalloc=&lt;size&gt; to increase size</span><br><span class="line">[ 7499.910499] platform cma: Fail to allocate buffer</span><br><span class="line">[ 7499.941821] vmap allocation for size 5537792 failed: use vmalloc=&lt;size&gt; to increase size</span><br><span class="line">[ 7499.952483] platform cma: Fail to allocate buffer</span><br><span class="line">[ 7499.983029] vmap allocation for size 5537792 failed: use vmalloc=&lt;size&gt; to increase size</span><br></pre></td></tr></table></figure>
<p>通过查看显示相关的进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t7-p3:/ # procrank</span><br><span class="line">  PID       Vss      Rss      Pss      Uss     Swap    PSwap    USwap    ZSwap  cmdline</span><br><span class="line"></span><br><span class="line"> 2387  1050156K  141496K   43392K   32760K       0K       0K       0K       0K  com.android.systemui</span><br><span class="line"> </span><br><span class="line">                           ------   ------   ------   ------   ------   ------  ------</span><br><span class="line">                          479314K  354572K     708K     708K     708K     534K  TOTAL</span><br><span class="line"></span><br><span class="line">ZRAM: 676K physical used for 896K in swap (754616K total swap)</span><br><span class="line"> RAM: 1006160K total, 50708K free, 2984K buffers, 513540K cached, 1016K shmem, 46584K slab</span><br><span class="line"></span><br><span class="line">查看对应的dma_buf分配情况,发现个数不断的增大</span><br><span class="line"></span><br><span class="line">procmem -p 2387 | grep dmabuf | grep 1948 | wc -l</span><br></pre></td></tr></table></figure></p>
<p>通过在ion_map的时候将进程信息添加到对应的ion debug节点中，unmap再删除，看到异常的dmabuf对应的进程；对应的是2880 systemui和launcher</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t7-p3:/ # cat /sys/kernel/debug/ion/heaps/cma | grep dmabuf | grep 1994</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  2217/android.display  dmabuf:172      | 3426/Binder:3413_2    dmabuf:172      |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  3168/Binder:2880_6    dmabuf:d3       | 9217/Binder:3413_4    dmabuf:d3       |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  9347/Binder:2880_9    dmabuf:13e      | 3426/Binder:3413_2    dmabuf:13e      |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  2217/android.display  dmabuf:17a      | 9217/Binder:3413_4    dmabuf:17a      | 2894/Binder:2880_1    dmabuf:17a      |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  2217/android.display  dmabuf:16a      | 2894/Binder:2880_1    dmabuf:16a      | 3426/Binder:3413_2    dmabuf:16a      |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  3426/Binder:3413_2    dmabuf:105      | 9168/Binder:2880_7    dmabuf:105      |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  2895/Binder:2880_2    dmabuf:a5       | 9217/Binder:3413_4    dmabuf:a5       |</span><br><span class="line"> allocator@2.0-s             1966          1994752 0 1 |  9347/Binder:2880_9    dmabuf:da       | 9217/Binder:3413_4    dmabuf:da       |</span><br></pre></td></tr></table></figure>
<p>跟踪logcat中gralloc alloc的时候的打印，发现异常截图size与截图的大小一致；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">03-26 19:34:17.096  1980  2160 D SurfaceFlinger: captureLayers here sourcecrop = 0 0 - 1920 720</span><br><span class="line">03-26 19:34:17.108  2186  2212 E KernelCpuSpeedReader: Failed to read cpu-freq: /sys/devices/system/cpu/cpu0/cpufreq/stats/time_in_state (No such file or directory)</span><br><span class="line">03-26 19:34:17.109  1965  2107 I [Gralloc]: ion_alloc from ion_client:5 via heap type DMA(mask:16) for 1990720 Bytes cached buffer successfully, usage = 0x00000333</span><br></pre></td></tr></table></figure>
<h2><span id="内存回收">内存回收</span></h2><p>首先怀疑是否为安卓内存没有回收导致</p>
<p>强制触发内存回收</p>
<pre><code>方式一：kill -10 pid
方式二：am dumpheap com.test.test /sdcard/test.hprof
方式三：在进程onReceive中添加System.gc() ;然后在adb shell中输入 am  broadcast -a INTENT_ACTION_NAME_HERE
</code></pre><p>安卓系统内存回收可以分为三种情况：</p>
<pre><code>第一，用户程序调用StartAcitity(),使当前的活动的Activity被覆盖；
第二，用户按BACK键，退出当前应用程序；
第三：启动一个新的应用程序。这些能够触发内存回收的时间最终调用的函数接口就是activityIdleInternal
</code></pre><p>通过kill -10 pid 的方式，触发安卓内存进行回收，发现内存没有释放；</p>
<p>从内核debug节点也看到此问题是上层systemui和launcher映射的fd没有释放导致；</p>
<h1><span id="休眠截屏流程">休眠截屏流程</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">services/core/java/com/android/server/wm/TaskSnapshotController.java</span><br><span class="line">/**</span><br><span class="line"> * Called when screen is being turned off.</span><br><span class="line"> */</span><br><span class="line">void screenTurningOff(ScreenOffListener listener) &#123;</span><br><span class="line">    if (shouldDisableSnapshots()) &#123;</span><br><span class="line">        listener.onScreenOff();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // We can&apos;t take a snapshot when screen is off, so take a snapshot now!</span><br><span class="line">    mHandler.post(() -&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            synchronized (mService.mWindowMap) &#123;</span><br><span class="line">                mTmpTasks.clear();</span><br><span class="line">                mService.mRoot.forAllTasks(task -&gt; &#123;</span><br><span class="line">                    if (task.isVisible()) &#123;</span><br><span class="line">                        mTmpTasks.add(task);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                snapshotTasks(mTmpTasks);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            listener.onScreenOff();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在休眠老化过程中，将shouldDisableSnapshots默认配置为true，没有出现内存泄漏，更加确定与截屏流程有关；</p>
<p><strong>进一步确认：</strong><br>配合dumpsys命令，传入虚拟内存地址和长度，最终调用如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void native_dumpAddr(JNIEnv* /* env */, jobject /* clazz */, jint addr, jint len) &#123;</span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; &quot;/storage/emulated/0/&quot; &lt;&lt; std::hex &lt;&lt; addr;</span><br><span class="line">    const char * path = ss.str().c_str();</span><br><span class="line"></span><br><span class="line">    int fd = open(path, O_CREAT | O_WRONLY | O_NOFOLLOW | O_CLOEXEC | O_APPEND, 0666);</span><br><span class="line">    if (fd &lt; 0) &#123;</span><br><span class="line">        ALOGI(&quot;error opening: %s: %s&quot;, path, strerror(errno));</span><br><span class="line">	return;</span><br><span class="line">    &#125;</span><br><span class="line">    write(fd, (void *)addr, len);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接在泄漏进程中直接dump虚拟内存内容，转换成图片格式后，确认为截图；</p>
<h1><span id="测试场景脚本化">测试场景脚本化</span></h1><p>在出现异常的现场时，如果能简化到某些行为，可以使debug的范围很大程度的缩小；在验证问题是否解决的时，也更容易判断</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">	am start -n com.android.calculator2/com.android.calculator2.Calculator</span><br><span class="line">	sleep 0.5 </span><br><span class="line">	am start -n com.android.settings/com.android.settings.Settings</span><br><span class="line">	sleep 0.5</span><br><span class="line">done</span><br><span class="line">或</span><br><span class="line">while true;</span><br><span class="line">do</span><br><span class="line">	input keyevent POWER</span><br><span class="line">	sleep 1</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h1><span id="怀疑方向">怀疑方向</span></h1><p>从泄漏问题来看，有两点有疑问，一： 主界面为什么不泄露，设置界面泄漏？二：为什么与截屏流程有关,且影响到systemUI和launcher?</p>
<h2><span id="主界面没有泄漏原因">主界面没有泄漏原因</span></h2><p>从log上看主界面之所以没有泄漏，是因为主界面不走截屏的流程；那么下一步的动作就是看为什么主界面没有截屏</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/** Activity type is currently not defined. */</span><br><span class="line">public static final int ACTIVITY_TYPE_UNDEFINED = 0;</span><br><span class="line">/** Standard activity type. Nothing special about the activity... */</span><br><span class="line">public static final int ACTIVITY_TYPE_STANDARD = 1;</span><br><span class="line">/** Home/Launcher activity type. */</span><br><span class="line">public static final int ACTIVITY_TYPE_HOME = 2;</span><br><span class="line">/** Recents/Overview activity type. There is only one activity with this type in the system. */</span><br><span class="line">public static final int ACTIVITY_TYPE_RECENTS = 3;</span><br><span class="line">/** Assistant activity type. */</span><br><span class="line">public static final int ACTIVITY_TYPE_ASSISTANT = 4;</span><br><span class="line"></span><br><span class="line">   int getSnapshotMode(Task task) &#123;</span><br><span class="line">       final AppWindowToken topChild = task.getTopChild();</span><br><span class="line">       if (!task.isActivityTypeStandardOrUndefined() &amp;&amp; !task.isActivityTypeAssistant()) &#123;</span><br><span class="line">           return SNAPSHOT_MODE_NONE;//主界面 </span><br><span class="line">       &#125; else if (topChild != null &amp;&amp; topChild.shouldUseAppThemeSnapshot()) &#123;</span><br><span class="line">           return SNAPSHOT_MODE_APP_THEME;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return SNAPSHOT_MODE_REAL;//设置界面</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>结合打印和代码可以发现，由于主界面activity属性为ACTIVITY_TYPE_HOME，故不截屏；而设置界面中，activity属性为ACTIVITY_TYPE_STANDARD；故进行截屏；</p>
<p>dumpsys window</p>
<p><img src="/2019/04/27/display/休眠唤醒cma内存泄漏/window.png" alt="window"></p>
<p>并无出现截图数量递增的情况；</p>
<p>安卓P上默认无论是否为低内存设备不再提供禁止截屏的接口，把截屏的第一帧动画当做第一帧进行显示；低内存只能更改第一帧的采样率</p>
<pre><code>services/core/java/com/android/server/wm/TaskSnapshotController.java
    final float scaleFraction = isLowRamDevice ? 1f : 1f;
</code></pre><h2><span id="截屏作用">截屏作用</span></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">./services/core/java/com/android/server/am/ActivityRecord.java showStartingWindow</span><br><span class="line">	showStartingWindow</span><br><span class="line">		addStartingWindow //添加启动窗口</span><br><span class="line">			final TaskSnapshot snapshot = mService.mTaskSnapshotController.getSnapshot(</span><br><span class="line">        	mContainer.getTask().mTaskId, mContainer.getTask().mUserId,</span><br><span class="line">       		false /* restoreFromDisk */, false /* reducedResolution */);//休眠的时候系统会通过TaskController进行截图</span><br><span class="line">			</span><br><span class="line">			final int type = getStartingWindowType(newTask, taskSwitch, processRunning,</span><br><span class="line">        	allowTaskSnapshot, 、activityCreated, fromRecents, snapshot);</span><br><span class="line">			获取启动窗口的类型，如果启动串口的类型是STARTING_WINDOW_TYPE_SNAPSHOT时，使用snapshot内容作为启动窗口内容</span><br><span class="line">			一般我们从recents界面进入应用时，或者应用被压入后台再次点击桌面图标进入应用时走该流程；</span><br><span class="line">			窗口类型：</span><br><span class="line">				STARTING_WINDOW_TYPE_NONE：不添加starting window</span><br><span class="line">				STARTING_WINDOW_TYPE_SNAPSHOT：使用任务快照作为starting window的显示内容</span><br><span class="line">				STARTING_WINDOW_TYPE_SPLASH_SCREEN：默认行为，该界面显示的内容搜应用主题相关属性设置的影响</span><br><span class="line"></span><br><span class="line">			一般情况下我们可以通过设置theme的windowDisablePreview的属性为true禁止显示starting window,如果我们设置了应用窗口背景透明或者使用了float属性为true类型的窗口时，这个时候启动应用时不会添加starting window的。</span><br><span class="line">			对于启动窗口的内容何时使用snapshot内容合适受应用的theme影响。我们可以以应用启动方式不同来做一判断，一般应用冷启动和温启动的时候staring window的显示容易受theme影响，应用通过Recent启动或者热启动时，starting window会显示snapshot的内容</span><br><span class="line">			 if (type == STARTING_WINDOW_TYPE_SNAPSHOT) &#123;</span><br><span class="line">    					 return createSnapshot(snapshot);</span><br><span class="line"> 				&#125;</span><br></pre></td></tr></table></figure>
<p>即截图的图片在启动动画的时候会用来做第一帧动画；如果有keyguard的时候，唤醒启动的时候则会去那休眠前截好的图作为第一帧动画显示；没有则不用走到这里来；T7没有keyguard，故休眠唤醒的流程也不会经过这里；</p>
<h1><span id="systemui截屏相关流程">SystemUi截屏相关流程</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">启动流程：</span><br><span class="line">	startOtherServices()</span><br><span class="line">		startSystemUi(context, windowManagerF);</span><br><span class="line">			intent.setComponent(new ComponentName(&quot;com.android.systemui&quot;,&quot;com.android.systemui.SystemUIService&quot;));</span><br><span class="line">			context.startServiceAsUser(intent, UserHandle.SYSTEM);</span><br><span class="line"></span><br><span class="line">		src/com/android/systemui/SystemUIService.java	</span><br><span class="line">		onCreate()</span><br><span class="line">				((SystemUIApplication) getApplication()).startServicesIfNeeded();</span><br><span class="line">					mServices[i].start();</span><br><span class="line">	这时候就会去起recent的服务</span><br><span class="line"></span><br><span class="line">截图相关流程</span><br><span class="line">	getThumbnail	只是提供缩略图的作用</span><br><span class="line">		snapshot = ActivityManager.getService().getTaskSnapshot(taskId, reducedResolution);</span><br><span class="line">			return task.getSnapshot(reducedResolution);</span><br><span class="line">				task = mStackSupervisor.anyTaskForIdLocked(taskId,</span><br><span class="line">        				MATCH_TASK_IN_STACKS_OR_RECENT_TASKS);</span><br><span class="line">			return task.getSnapshot(reducedResolution);</span><br></pre></td></tr></table></figure>
<p>在休眠唤醒的流程里面，添加打印，并未发现有systemui进入到getSnapshot的相关操作。至此在应用排查阶段一直没有进展；另外烧录gsi同样能发现内存泄漏的问题；怀疑还是自己平台修改导致的可能性比较大；故在目光转移至gralloc分配流程；</p>
<h1><span id="进程的地址空间">进程的地址空间</span></h1><p>进程的地址空间（address space）由允许进程使用的全部线性地址（memery region，其含义通常所指的虚拟内存的一个区间，可以称为虚存区 VMA Virtual Memory Area ）组成。每个进程所看到的线性地址集成是不同的，一个进程所使用的地址和另外一个进程所使用的地址之间没有什么关系。后面我们还会看到，内核可以通过增加或删除某些线性地址区间来动态地修改进程的地址空间；</p>
<p>内存描述符：与进程地址空间有关的全部信息都包含在一个叫做内存描述符（memory descriptor）的数据结构中，这个类型为mm_struct,进程描述符的mm字段就指向这个内存结构；</p>
<h1><span id="ion基本概念">ION基本概念</span></h1><p>ION作用：用于用户空间的进程之间或者内核空间的模块之间进行内存共享；而且这种共享是0拷贝的；</p>
<p>对于ION的基本概念可以看下篇文章；</p>
<p><a href="http://kernel.meizu.com/memory%20management%20-%20ion.html" target="_blank" rel="noopener">内存管理–ION</a></p>
<h2><span id="free时机">free时机</span></h2><p>一般我们认为当ref_count = 0的时候就会去release这块内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">drivers/staging/android/ion/ion.c</span><br><span class="line">ion_buffer_put(struct ion_buffer *buffer)</span><br><span class="line">	 return kref_put(&amp;handle-&gt;ref, _ion_handle_destroy);</span><br><span class="line">		return kref_sub(kref, 1, release); </span><br><span class="line">			 if (atomic_sub_and_test((int) count, &amp;kref-&gt;refcount)) &#123; </span><br><span class="line">    			release(kref);</span><br><span class="line">                    ion_buffer_destroy</span><br><span class="line">			            buffer-&gt;heap-&gt;ops-&gt;free(buffer);</span><br><span class="line">						vfree(buffer-&gt;pages);           </span><br><span class="line">						kfree(buffer);</span><br></pre></td></tr></table></figure>
<p>可以看到ion buffer的free动作是在在引用计数为0的时候去清理的；实际此时当不同进程都map到同一个buffer的时候，这时候还有一个引用计数会决定是否真正的close;</p>
<p>通过ioct free的时候</p>
<table>
<thead>
<tr>
<th>Object</th>
<th>Operations</th>
<th>Ion buffer ref count</th>
<th>Ion buf status</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="mailto:allocator@2.0-s" target="_blank" rel="noopener">allocator@2.0-s</a>(alloc_device_alloc)</td>
<td>1.ion_alloc</td>
<td>1</td>
<td>allocated</td>
</tr>
<tr>
<td></td>
<td>2.ion share:dmabuf fd1</td>
<td>2</td>
<td>—</td>
</tr>
<tr>
<td>surfaceflinger</td>
<td>gralloc_register_buffer<br>(map)</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>surfaceflinger</td>
<td>gralloc_lock</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>surfaceflinger</td>
<td>gralloc_unlock</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>surfaceflinger</td>
<td>gralloc_unregister_buffer<br>(unmap)</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td><a href="mailto:allocator@2.0-s" target="_blank" rel="noopener">allocator@2.0-s</a>(alloc_device_free)</td>
<td>3.close(ion buffer个数不减少)</td>
<td>2</td>
<td>—</td>
</tr>
<tr>
<td></td>
<td>4.ion_free</td>
<td>1(2 -&gt; 1)</td>
<td>using</td>
</tr>
<tr>
<td>systemUI</td>
<td>gralloc_register_buffer<br>(map)</td>
<td>1</td>
<td>using</td>
</tr>
<tr>
<td>systemUI</td>
<td>FinalizerDaemon<br>gralloc_unregister_buffer<br>(unmap)</td>
<td>0(1 -&gt; 0)</td>
<td>freed</td>
</tr>
</tbody>
</table>
<h2><span id="内存映射">内存映射</span></h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其他对象映射到进程的地址空间，实现文件磁盘地址和虚拟内存</p>
<p><img src="/2019/04/27/display/休眠唤醒cma内存泄漏/mmap.png" alt="mmap流程"></p>
<p><strong>mmap三个阶段：</strong></p>
<p>一：进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；</p>
<p>二：调用内核空间的系统调用函数mmap(不同于用户空间函数)，实现文件物理地址和进程虚拟地址的一一映射关系</p>
<p>三：进程发起对这片映射空间的访问，引发缺页异常；实现文件内容到物理内存（主存）的拷贝</p>
<p><strong>内存映射类型：</strong></p>
<p>私有内存映射：多个进程会创建一个新的映射，各个进程不共享，也不会反应到物理文件中，比如linux.so动态库就是采用这种形式映射到各个进程虚拟地址空间中；</p>
<p>私有匿名映射：mmap会创建一个新的映射，各个进程不共享，这种使用主要用于分配内存</p>
<p>共享文件映射：多个进程通过虚拟内存技术共享同样的物理内存空间，对内存文件会反映到实际物理文件中，他也是进程通信的机制</p>
<p>共享匿名映射：这种机制在fork的时候不会采用写时复制，父子进程完全共享同样的物理内存，这也就实现了父子间通信（IPC）</p>
<p>匿名的意思是需不需要一个fd,正常来讲，当需要进行内存映射的时候，我们都需要依赖一个文件才能实现；通常需要open一个temp文件，穿件后unlink，close掉，比较麻烦；可以直接使用匿名映射来代替，linux也提供了这么一套机制给我们；无需依赖文件即可创建。：</p>
<font color="green">如：int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);</font> 



<p><strong>映射流程：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DPATH=&quot;/sys/kernel/debug/tracing&quot;</span><br><span class="line">echo &gt; $DPATH/trace</span><br><span class="line">echo nop &gt; $DPATH/current_tracer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">echo &gt; $DPATH/set_ftrace_filter</span><br><span class="line">echo &quot;SyS_mmap_pgoff SyS_old_mmap SyS_munmap SyS_open filp_open &quot; &gt;&gt; $DPATH/set_ftrace_filter</span><br><span class="line">echo &quot;do_brk elf_map load_elf_binary&quot; &gt;&gt; $DPATH/set_ftrace_filter</span><br><span class="line">echo &quot;do_mmap do_munmap get_unmapped_area mmap_region vm_mmap vm_munmap vm_mmap_pgoff&quot; &gt;&gt; $DPATH/set_ftrace_filter</span><br><span class="line">echo &quot;__split_vma unmap_region split_vma&quot; &gt;&gt; $DPATH/set_ftrace_filter</span><br><span class="line"></span><br><span class="line">echo function_graph &gt; $DPATH/current_tracer</span><br><span class="line">echo 2542 &gt; $DPATH/set_ftrace_pid</span><br><span class="line"></span><br><span class="line">echo 1 &gt; $DPATH/tracing_on</span><br><span class="line">cat $DPATH/trace &gt; /data/trace.txt</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> mappedAddress = (unsigned char *)mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, hnd-&gt;share_fd, 0);</span><br><span class="line"></span><br><span class="line"> 1)               |  SyS_mmap_pgoff() &#123;</span><br><span class="line"> 1)               |    vm_mmap_pgoff() &#123;</span><br><span class="line"> --&gt;              |     do_mmap_pgoff</span><br><span class="line"> 1)               |      do_mmap() &#123;</span><br><span class="line"> 1) + 27.334 us   |        get_unmapped_area();</span><br><span class="line"> 1) + 15.792 us   |        mmap_region();</span><br><span class="line"> 1) + 53.583 us   |      &#125;</span><br><span class="line"> 1) + 60.958 us   |    &#125;</span><br><span class="line"> 1) + 66.250 us   |  &#125;</span><br><span class="line"> </span><br><span class="line">munmap(base, size) </span><br><span class="line"> </span><br><span class="line"> 1)               |  SyS_munmap() &#123;</span><br><span class="line"> 1)               |    do_munmap() &#123;</span><br><span class="line"> 1) + 85.084 us   |      unmap_region();</span><br><span class="line"> 1) ! 105.667 us  |    &#125;</span><br><span class="line"> 1) ! 111.458 us  |  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>do_map</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">do_mmap</span><br><span class="line">	//获取未映射的vma</span><br><span class="line">	 addr = get_unmapped_area(file, addr, len, pgoff, flags); </span><br><span class="line">	 //先检查vma分配后是否超过进程限制，之后再rb_tree中找到满足本次申请条件vma的前区vma区（内核有很多红黑树存储的数据结构，尤其在内存中）</span><br><span class="line">	 //如果两个vma能合并就合并成一个，否则就新申请的vma插入rb_tree中。</span><br><span class="line">	 //在整个过程中，我们能看到的只有vma的申请和磁盘文件的关联</span><br><span class="line">	 addr = mmap_region(file, addr, len, vm_flags, pgoff);</span><br><span class="line">	 	vma = vma_merge(mm, prev, addr, addr + len, vm_flags,</span><br><span class="line">        NULL, file, pgoff, NULL, NULL_VM_UFFD_CTX, NULL);</span><br><span class="line">	 	vma-&gt;vm_file = get_file(file);  </span><br><span class="line">			atomic_long_inc(&amp;f-&gt;f_count);</span><br><span class="line">		error = file-&gt;f_op-&gt;mmap(file, vma);通过fd进行内存映射</span><br></pre></td></tr></table></figure>
<p><strong>unmap流程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">do_munmap</span><br><span class="line">	vma = find_vma(mm, start); //找到起始地址落在哪个vma内</span><br><span class="line">	unmap_region(mm, vma, prev, start, end);</span><br><span class="line">	error = __split_vma(mm, vma, start, 0); //上面有讲到如果两个vma能合并就合并，解映射的时候分离出来</span><br><span class="line">	remove_vma_list(mm, vma); </span><br><span class="line">		vma = remove_vma(vma);</span><br><span class="line">			fput(vma-&gt;vm_file); </span><br><span class="line">				atomic_long_dec_and_test(&amp;file-&gt;f_count)</span><br><span class="line">					schedule_delayed_work</span><br><span class="line">						delayed_fput</span><br><span class="line">							__fput</span><br><span class="line">								file-&gt;f_op-&gt;release(inode, file);</span><br></pre></td></tr></table></figure>
<p>释放时的log</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[ 1689.870445] ion_buffer_put count:0 phys_adr 72100000 </span><br><span class="line">[ 1689.877035] CPU: 2 PID: 3353 Comm: FinalizerDaemon Tainted: G           O    4.9.118 #2</span><br><span class="line">[ 1689.885982] Hardware name: sun8iw17</span><br><span class="line">[ 1689.889931] [&lt;c0111184&gt;] (unwind_backtrace) from [&lt;c010cd1c&gt;] (show_stack+0x20/0x24)</span><br><span class="line">[ 1689.898604] [&lt;c010cd1c&gt;] (show_stack) from [&lt;c0478c5c&gt;] (dump_stack+0x78/0x94)</span><br><span class="line">[ 1689.906703] [&lt;c0478c5c&gt;] (dump_stack) from [&lt;c06fb5f4&gt;] (ion_buffer_put+0xc0/0xd4)</span><br><span class="line">[ 1689.915177] [&lt;c06fb5f4&gt;] (ion_buffer_put) from [&lt;c06fb7fc&gt;] (ion_dma_buf_release+0x1c/0x20)</span><br><span class="line">[ 1689.924520] [&lt;c06fb7fc&gt;] (ion_dma_buf_release) from [&lt;c0585b60&gt;] (dma_buf_release+0x64/0x17c)</span><br><span class="line">[ 1689.934049] [&lt;c0585b60&gt;] (dma_buf_release) from [&lt;c02843cc&gt;] (__fput+0xf4/0x1d0)</span><br><span class="line">[ 1689.942319] [&lt;c02843cc&gt;] (__fput) from [&lt;c0284518&gt;] (____fput+0x18/0x1c)</span><br><span class="line">[ 1689.949806] [&lt;c0284518&gt;] (____fput) from [&lt;c013f574&gt;] (task_work_run+0xc8/0xd8)</span><br><span class="line">[ 1689.957976] [&lt;c013f574&gt;] (task_work_run) from [&lt;c010c458&gt;] (do_work_pending+0xac/0xcc)</span><br><span class="line">[ 1689.966819] [&lt;c010c458&gt;] (do_work_pending) from [&lt;c0107f60&gt;] (slow_work_pending+0xc/0x20)</span><br></pre></td></tr></table></figure>
<p>只有当映射同一块进程都解除映射后，file-&gt;f_count,为0；才会调到ion_buffer_put，此时ion_buffer计数为0，释放该buffer</p>
<h2><span id="userspace-使用">userspace 使用</span></h2><p>mali-utgard/gralloc/src/gralloc_module.cpp</p>
<p>进程创建buffer的流程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct hw_module_methods_t gralloc_module_methods =</span><br><span class="line">&#123;</span><br><span class="line">    .open = gralloc_device_open</span><br><span class="line">&#125;;   </span><br><span class="line">                                                      </span><br><span class="line">	gralloc_device_open</span><br><span class="line">		alloc_device_open</span><br><span class="line">			 m-&gt;ion_client = ion_open();</span><br><span class="line">	alloc_device_alloc</span><br><span class="line">		gralloc_alloc_buffer</span><br><span class="line">			ret = aw_ion_alloc(&amp;(m-&gt;ion_client), size, 0, heap_mask, flags, &amp;(ion_hnd), usage);</span><br><span class="line">			ret = ion_share(m-&gt;ion_client, ion_hnd, &amp;shared_fd);</span><br><span class="line">			cpu_ptr = mmap(NULL, size, map_mask, MAP_SHARED, shared_fd, 0);</span><br></pre></td></tr></table></figure></p>
<p> 结构体gralloc_module_t定义在文件hardware/libhardware/include/hardware/gralloc.h中，它主要是定义了四个用来操作图形缓冲区的成员函数，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private_module_t::private_module_t()</span><br><span class="line">&#123;</span><br><span class="line">```	                                                  </span><br><span class="line">	base.registerBuffer = gralloc_register_buffer;</span><br><span class="line">	base.unregisterBuffer = gralloc_unregister_buffer;</span><br><span class="line">	base.lock = gralloc_lock;                         </span><br><span class="line">	base.unlock = gralloc_unlock;</span><br><span class="line">```</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>registerBuffer和unregisterBuffer分别用来注册和注销一个指定的图形缓冲区，这个指定的图形缓冲区使用一个buffer_handle_t句柄来描述。所谓注册图形缓冲区，实际上就是将一块图形缓冲区映射到一个进程的地址空间，注销图形缓冲区则是相反的过程；成员函数lock和unlock分别用来锁定和解锁一个缓冲区，例如向一块图形缓冲写入内容的时候，需要将图形缓冲区锁定。用来避免访问冲突；</p>
<h1><span id="gralloc-流程debug">gralloc 流程debug</span></h1><p>对于systemui来讲，在此过程并不会去申请buffer,而是通过内存映射，所以我们主要关注register和unregiser的流程</p>
<p>添加引用计数：</p>
<pre><code>gralloc_register_buffer
     if (size == 1990720) {
                   getNameByPid(hnd-&gt;pid,task_name);       
                   count = count + 1;
                   AERR(&quot; 0x%p process %d  task_name:%s size:%d share_fd:0x%x count:%d &quot;, hnd, hnd-&gt;pid, task_name, size, hnd-&gt;share_fd, count);
     }

gralloc_unregister_buffer        
if (size == 1990720) {
                   getNameByPid(hnd-&gt;pid,task_name);       
                   count= count -1;
                   AERR(&quot; 0x%p process %d  task_name:%s size:%d share_fd:0x%x count:%d &quot;, hnd, hnd-&gt;pid, task_name, size, hnd-&gt;share_fd, count);
}
</code></pre><p>应用计数log:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gralloc_unregister_buffer:345  0x0xa96c52c0 process 2327  task_name:ndroid.systemui size:1990720 share_fd:0x5b count:2</span><br><span class="line">   gralloc_unregister_buffer:345  0x0xaeca7400 process 2327  task_name:ndroid.systemui size:1990720 share_fd:0x59 count:1</span><br><span class="line">gralloc_unregister_buffer:345  0x0xaeccd7f0 process 2327  task_name:ndroid.systemui size:1990720 share_fd:0x4c count:0</span><br></pre></td></tr></table></figure></p>
<p>通过打印发现，systemUI的register动作和unregister的动作是匹配的，count也能清零；但依然进程中的dmabuf异常存在泄漏</p>
<p>对应的dmabuf如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t7-p3:/ # procmem  -p 2327 | grep dmabuf</span><br><span class="line"> 	1948K       0K       0K       0K       0K       0K       0K       0K  anon_inode:dmabuf-c3</span><br></pre></td></tr></table></figure></p>
<p>且kill -10 后系统也没有完成回收，说明此时已经存在内存泄漏</p>
<p>查看unregister相关代码发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gralloc_unregister_buffer</span><br><span class="line">....</span><br><span class="line">    /* if handle is still locked, the unmapping would not happen until unlocked*/</span><br><span class="line">    if (!(hnd-&gt;lockState &amp; private_handle_t::LOCK_STATE_WRITE))</span><br><span class="line">    &#123;</span><br><span class="line">        unmap_buffer(hnd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hnd-&gt;lockState |= private_handle_t::LOCK_STATE_UNREGISTERED;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>当存在LOCK_WRITE标识的时候，此时不会被unmap,那么什么时候这个标志是什么时候被赋值的呢？surfaceFlinger在创建这块内存时，对于surfaceFlinger而言；由于截图的动作比较频繁，会调用lock为buffer添加锁保护，当写完之后unlock;这时候systemUI恰好映射到这块内存恰好会将其标志拷贝；对于systemUI而言，本身不会有写的操作，故更不会有unlock的动作；所以就发生了泄漏；解决这个问题的方法。就是在进程映射内存的时候；将这个标志清除掉；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gralloc_register_buffer</span><br><span class="line">	hnd-&gt;lockState &amp;= ~(private_handle_t::LOCK_STATE_WRITE);</span><br></pre></td></tr></table></figure>
<p>安卓O同样存在同样的问题，但由于项目一开始为了减少设备的内存使用，所以禁止了相关截图的功能，在androidP上，谷歌没有提供相关的全局禁止功能，故问题就暴露出来；</p>
<p>补丁如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在方案下面的:venus_a1.mk</span><br><span class="line">Disable the task snapshots feature</span><br><span class="line">PRODUCT_PROPERTY_OVERRIDES += \</span><br><span class="line"></span><br><span class="line">persist.enable_task_snapshots = false</span><br></pre></td></tr></table></figure>
<h1><span id="补充代办">补充（代办）</span></h1><h2><span id="上层的gralloc流程">上层的gralloc流程</span></h2><h2><span id="systemui如何map到surfaceflinger">systemUI如何map到surfaceFlinger</span></h2><h1><span id="参考资料">参考资料</span></h1><p><a href="http://zhoujinjian.cc/2019/06/23/Android%20P%20Graphics%20System%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AGraphicBuffer%E5%92%8CGralloc%E5%88%86%E6%9E%90/index.html" target="_blank" rel="noopener">gralloc流程</a></p>
<p><a href="https://www.jianshu.com/p/97fb764f2669" target="_blank" rel="noopener">安卓性能优化：关于内存泄漏的知识都在这里了</a></p>
<p><a href="https://blog.csdn.net/abm1993/article/details/88641725" target="_blank" rel="noopener">Activity启动窗口和TaskSnapshot</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-android-mmry-rcycl/index.html" target="_blank" rel="noopener">Android操作系统的内存回收机制</a></p>
<p><a href="http://gityuan.com/2016/04/16/kill-signal/" target="_blank" rel="noopener">信号处理</a></p>
<p><a href="http://windrunnerlihuan.com/2018/01/09/Android-SurfaceFlinger-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-%E5%8D%81%E4%BA%8C-%E5%90%88%E6%88%90Layer/" target="_blank" rel="noopener">Android SurfaceFlinger学习之路</a></p>
<p><a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener">认真分析mmap:是什么 为什么 怎么用</a></p>
<p><a href="https://www.cnblogs.com/arnoldlu/p/9367253.html" target="_blank" rel="noopener">Linux内存管理（9）mmap补充</a></p>
<p><a href="https://blog.csdn.net/SweeNeil/article/details/83661933" target="_blank" rel="noopener">匿名映射</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/27/display/display_hardware/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/27/display/display_hardware/" itemprop="url">显示硬件篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-27T00:07:09+00:00">
                2019-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/display/" itemprop="url" rel="index">
                    <span itemprop="name">display</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="lcd成像">lcd成像</span></h1><p>由于市场上只有高端产品如手机屏幕才用OLED，但大部分依然是LCD，故将以LCD成像原理开启此篇；</p>
<p><img src="/2019/02/27/display/display_hardware/lcd_display.png" alt="lcd成像原理"></p>
<p>偏振光：指单方向的光，自然光为散光，如果不经过偏振片，可以自由穿透液晶，这样就没办法起到选通作用；</p>
<p><strong>偏振片在3D电影院中的应用：</strong></p>
<p>为什么我们去3D影院需要带3D眼镜呢？3D眼镜其实就是两个不同方向的偏振片，我们人眼之所以看到的物体有3D效果，原因在于左眼和右眼存在一定的距离，当人眼将这两种图像传递给大脑后，大脑就会合成一个3D的图像，所以我们如果想看到3D的图像，必定是传递到我们的眼睛的图形存在偏移；在电影院中，3D电影就是横向和纵向的光源叠加，经过3D眼睛时，假设左眼镜片为只能透过横偏振光，右眼只能透过纵偏振光，那么通过左右眼的时候就会有两个图像；这样人眼就能看到3D效果；</p>
<p>接下来我们就可以大胆猜想下OLED，由于自发光的特性，那么背光和偏振片都是不必要的；这样就可以做的更薄；由于没有背光电路，OLED可以做到不漏光，而且响应速度更快，较LCD更适用于VR产品上；</p>
<h2><span id="lcd常用到的知识">lcd常用到的知识</span></h2><ol>
<li>残影: 是指画面切换之后一个画面不会立即消失，而是慢慢不见的现象；</li>
<li>坏点：是指液晶屏上无法控制的恒亮或者恒暗的点；</li>
<li>mura: 显示器亮度不均匀造成各种痕迹的现象；</li>
<li>色饱和度（色域）： 色饱和度是指显示器色彩鲜艳的程度，显示器是由红，绿，蓝三种颜色来组合成任意颜色光；</li>
<li>亮度： 亮度是显示器在白色画面下的明亮程度，俗话说一亮遮三丑</li>
<li>视角：液晶显示器由于天生的物理特性，使得使用者从不同角度看画质会有所变化；与正眼相比，斜看的时候，转到当前画面品质已经变化到无法接受的临界角度。称为显示器的视角</li>
<li>Gamma Curve：是指不同灰阶与亮度的关系曲线。把0~255灰阶当x轴，亮度当y轴，画出来的线就叫做gamma curve;因为人眼对不同亮度有不同的辨识效果，比如说低亮度的辨识能力较高</li>
</ol>
<h1><span id="常用的显示接口">常用的显示接口</span></h1><h2><span id="a83的结构图">A83的结构图</span></h2><p><img src="/2019/02/27/display/display_hardware/A83_system.jpg" alt="A83结构图"><br>从A83的结构图可以看到支持的显示接口有RGB,LVDS,HDMI,MIPI</p>
<h2><span id="lcd常用接口">LCD常用接口</span></h2><table>
<thead>
<tr>
<th>接口</th>
<th>接口定义</th>
<th>接口介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>RGB</td>
<td>RGB颜色是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的</td>
<td>接口一般为3.3V电平，需要同步信号，需要时刻刷新图像数据，需要适当的timing</td>
</tr>
<tr>
<td>LVDS</td>
<td>Low Voltage Differential Signaling，是一种低压差分信号技术接口。它是美国NS公司为克服以TTL电平方式传输宽带高码率数据时功耗大、EMI电磁干扰大等缺点而研制的一种数字视频信号传输方式</td>
<td>高速率（一般655Mbps）低电压，低功耗，低EMI(摆幅350mv)抗干扰能力强，差分信号</td>
</tr>
<tr>
<td>MIPI</td>
<td>MIPI联盟定义了一套接口标准，把移动设备内部的接口如摄像头、显示屏、基带、射频接口等标准化，从而增加设计灵活性，同时降低成本、设计复杂度、功耗和EMI，在移动设备十分常见</td>
<td>高速：1Gbps/Lane，4Gbps吞吐量<br>低功耗：200mV差分摆幅，200mv共模电压<br>噪声抑制<br>更少的pin，PCB layout更方便</td>
</tr>
<tr>
<td>HDMI</td>
<td>High-Definition Multimedia Interface，数字接口，同时传输视频和音频，传输非压缩视频数据和压缩/非压缩的数字音频数据</td>
<td>a. TMDS Transition Minimized  Differential Signal 8bit~10bit直流平衡编码<br>每个时钟周期传输10bit数据 <br> b. EDID and DDC 实现设备间只能连接<br> c. Transfer Video and Audio 更低成本、连接更方便 <br>d. HDCP High-Bandwidth Digital Content Protection</td>
</tr>
</tbody>
</table>
<p>更多的时候，分辨率能支持的大小还是有IC本身设计决定的，与协议本身并没有太大的关系；</p>
<p>还有一个edp接口，这个接口也是超清的接口，目前的话在pc上居多，但对于移动设备，目前还是mipi的居多；有些IC甚至没有edp接口；</p>
<h1><span id="显示硬件流程框图">显示硬件流程框图</span></h1><p><img src="/2019/02/27/display/display_hardware/de_hardware.jpg" alt="harware"></p>
<p>DE合成或从dram中取出显示需要的数据，TCON0中包含RGB和LVDS，可以直接接显示器，MIPI相当于一个独立的IP,将TCON中的RGB信号转换成MIPI信号，再接到显示器；下面将按照显示流程框图对每个模块进行介绍；</p>
<h1><span id="dedisplay-egine">DE(display egine)</span></h1><p>如下为DE硬件结构框图：从结构图我们大致可以猜测到DE就是做些图形的处理和合成；</p>
<p>如图，该DE主要由两个RT-Mixer(实时合成模块)，一个是Mux(解复用模块)，一个Write-back(回写模块)，主要用于debug,输入依赖内存（DMA）总线，显示内容输出到TCON，再到HDMI/CVBS做显示，回写内容输出返回内存总线。 其中RT-Mixer模块为一个核，可以认为是一个独立的DE，通常DE0,DE1对应的就是RT-Mixer0和RT-Mixer1。</p>
<p>RT-Mixer有四个通道，分别从DMA获取图层内容，然后通过overlay(覆盖)和scale（缩放）模块后依次进行双双混合，最后送给TCON显示。四个通道中，有三个是UI通道和一个视频通道，两种类型通道使用的overlay和scale模块是不一样的，另外视频通道送混合前会进行proc1的处理；</p>
<p>类似的，RT-Mixer1有两个通道，其中一个UI通道和一个视频通道，它们的功能和RT-Mixer0是一样的；</p>
<p>Routing(通道选择)模块比较简单就是通过寄存器值把对应的4个通道输出到不同的通道，以便后续做混合，它的作用就是配置通道的Zorder.</p>
<p>Blender 进行alpha叠加</p>
<p><img src="/2019/02/27/display/display_hardware/RT-Mixer.jpg" alt="RT-mixer"></p>
<p>如图所示，视频的通道还会先经过proc1</p>
<p><img src="/2019/02/27/display/display_hardware/proc1.jpg" alt="proc1"></p>
<ol>
<li>FCE:Fresh and Contrast enhancement(鲜艳度和对比度增强)</li>
<li>BWS：Black and White Stretch(黑白电平拉伸) 又称灰度拉伸，就是检测到图像的灰度如果集中在某个区域，则将灰色值放大，从而获得比较好的视觉效果，例如可以把偏暗的图片变得明亮一些；</li>
<li>LTI:Lumiance transient improvement(瞬态亮度改善) 让图像中亮度变化过渡分界处变得更加清晰，例如黑白交界处会更加尖锐</li>
<li>PEAK：Luminance Peak(亮度峰化)，将输入亮度分量通过带通和高通滤波器获取到增益后叠加到原输入亮度，以增加亮度的峰化值；</li>
<li>ASE：Adaptive Saturation Enhancement(饱和度增强) 主要是对颜色信号进行自适应调整，使画面看起来更鲜艳，亮丽；</li>
<li>FCC:Fancy color curvature change(丽色曲率改善) 主要是通过颜色空间将RGB转换成HSV，对颜色曲率进行调整，再转换回RGB输出；</li>
</ol>
<p><img src="/2019/02/27/display/display_hardware/proc2.jpg" alt="proc1"><br>如上图，在RT-Mixer0最后的proc2模块是CSC：Color Space Conversion(颜色空间转换)。由于前端输入格式不同，或者一些图像处理算法需要把图像转成另外的格式，所以需要在输出到显示器前格式统一转换成RGB</p>
<h1><span id="tcontimingcontrol">TCON(TimingControl)</span></h1><p><img src="/2019/02/27/display/display_hardware/tcon.jpg" alt="tcon结构图"></p>
<p>从结构图可以推测下，TCON主要的主要事情就是准备显示数据，还有显示上的时序；从TCON出来的数据就包含这RGB和LVDS这两种信号；如果需要转换成MIPI还需要经过硬件上的MIPI模块进行处理；<br>TCON有时还负责一些数据处理，如抖色（dither function），简单来讲就是增加像素的位数，以便显示效果能够更加细腻；现在主流的储存/显示方式是用8位记录每种颜色，三种颜色加起来一共24位（再加上用来定义透明度的8位，有时也被称作32位），每位有256级，三种颜色相乘，一共16,777,216种颜色。这就是所谓的8位色深了，这个标准一般被称作True Color，苹果则通俗的称其Millionsof Colors。不过最后苹果被好多消费者告了，因为其实苹果早年打着Millions of Colors旗号销售的很多电脑的屏幕都不是真正的24位，而是成本更低的18位；但其他厂家也是如此，只不过大家对苹果的期望更高一点而已；靠抖色从18扩大到24位；从而图像的验色可以更加的细腻；另外还有3D fuction的支持，将一张图片，以左右眼的数据进行输出，以便让用户看到3D的效果，这个也是在这里进行处理的，如果要支持这种3D模式，同样的需要佩戴眼镜还有屏幕也需要进行支持；</p>
<h1><span id="mipimobile-industry-processor-interface">MIPI（Mobile Industry Processor Interface）</span></h1><p>在移动平台上，由于此接口较为常见，所以我们将此接口拿出来讲下；<br>MIPI是2003年由ARM,Nokia,ST,TI等公司成立的一个联盟，目的是把手机内部的接口如摄像头，显示屏接口，视频/基带接口标准化，，从而增加设计灵活性，同时降低成本、设计复杂度、功耗和EMI。。MIPI联盟下面有不同的WorkGroup，分别定义了一系列的手机内部接口标准，比如摄像头接口CSI,显示接口DSI，视频接口DingRF,麦克风、喇叭接口等；由于本篇内容主要将的是显示，故我们就从MIPI-DSI讲起；</p>
<p>MIPI-DSI是一种应用于显示技术的串行接口，兼容DPI（显示像素接口，Display Pixel Interface）,DBI(显示总线接口，Display Bus Interface)和DCS（显示命令集，Display Command Set）,以串行的方式发送像素信息或指令给外围，而且在传输的过程中享有自己独立的通信协议，包括数据包格式和纠错检错机制；</p>
<p>MIPI-DSI具备高速和低速模式两种模式，全部数据通道都可以用于单向的高速数据传输，但只有一个数据通道才可用于低速双向传输，从属端的状态信息，像素等式通过该数据通道返回，时钟通道专用于高速传输数据的过程中传输同步时钟信号，此外，一个主机端可允许同时与多个从属端进行通信；下图为MIPI接口的数据链路图示：</p>
<p><img src="/2019/02/27/display/display_hardware/mipi.jpg" alt="mipi数据链路"></p>
<p><strong>简易物理设备图示</strong></p>
<p><img src="/2019/02/27/display/display_hardware/CSI_DSI.jpg" alt="CSI_DSI.jpg"></p>
<h1><span id="mipi屏参考电路">mipi屏参考电路</span></h1><p><strong>电源和背光电路</strong></p>
<p><img src="/2019/02/27/display/display_hardware/lcd_backlight.jpg" alt="lcd_backlight"></p>
<p><strong>屏电路</strong></p>
<p><img src="/2019/02/27/display/display_hardware/lcd_mipi.jpg" alt="lcd_mipi"></p>
<p>从硬件原理图看mipi屏主要有三个主要的电路，<strong>供电</strong>：屏供电:VCC-LCD. MIPI信号供电：VCC-LCD-LOGIC；<strong>背光电路：</strong>通过lcd-pwm控制VCC-LED+,VCC-LED- ; <strong>MIPI信号：</strong>DSI-D0N,DSI-D0P,….,DSI-CKN,DSI-CKP;</p>
<h1><span id="lcd屏电路硬件简示">lcd屏电路硬件简示</span></h1><p><img src="/2019/02/27/display/display_hardware/lcd_hardware.png" alt="lcd_hardware"></p>
<p>按照之前的MIPI数据链路，将SOC的MIPI信号转化成屏可以识别的信号，然后进行显示</p>
<p><strong>综上，就是从DE-&gt;TCON-&gt;MIPI-&gt;LCD的硬件流程图;</strong></p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://blog.csdn.net/xubin341719/article/details/9125583" target="_blank" rel="noopener">Android LCD(一)：LCD基本原理篇</a></p>
<p><a href="https://blog.csdn.net/u012719256/article/details/55102836" target="_blank" rel="noopener">LCD主流显示接口介绍</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/33633476" target="_blank" rel="noopener">高兴说 显示行业进阶篇之（三）</a></p>
<p><a href="https://www.2cm.com.tw/2cm/zh-tw/archives/9A04B31883E84E3A8C3ED8D2C48920D5" target="_blank" rel="noopener">行動裝置顯示器邁向超高畫質　eDP躍升NB/平板主流介面</a></p>
<p><a href="https://diy.pconline.com.cn/display/study_screen/1104/2386860_all.html" target="_blank" rel="noopener">硝烟四起！各大3D显示器技术详细解读</a></p>
<p><a href="https://blog.csdn.net/digent1/article/details/17413187" target="_blank" rel="noopener">MIPI接口介绍</a></p>
<p><a href="https://blog.csdn.net/liwei16611/article/details/68146912" target="_blank" rel="noopener">LCD之mipi DSI接口驱动调试流程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/standby/kernel_suspend/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/standby/kernel_suspend/" itemprop="url">内核的休眠流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T00:07:09+00:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/standby/" itemprop="url" rel="index">
                    <span itemprop="name">standby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="内核休眠流程">内核休眠流程</span></h1><p>当安卓合适的时机(wakeup_count = save_count &amp;&amp; inpr == 0),与内核一致，在没有wakeup事件的时候，走进一步的流程，发echo mem &gt; /sys/power/state命令后，内核开始处理休眠流程</p>
<pre><code>./kernel/power/main.c 
state_store
    -&gt;pm_suspend
        -&gt;enter_state
</code></pre><h1><span id="休眠流程">休眠流程：</span></h1><p>按照内核划分的休眠测试环节分为，FREEZER(进程冻结),DEVICES(设备休眠),PLATFORM(关闭不必要的中断),CPUS(关闭noboot cpu)，core(关闭cpu中断，通知cpus进入休眠处理流程)几个阶段</p>
<p>kernel/power/suspend.c</p>
<pre><code>enter_state
    suspend_prepare(suspend_state_t state)
    error = suspend_devices_and_enter(state);
</code></pre><h2><span id="test_freezer冻结流程">test_freezer（冻结流程）</span></h2><pre><code>suspend_prepare(suspend_state_t state)    
        pm_prepare_console //如果需要的话重定向内核的kmsg  ??为什么要做切换
        error = pm_notifier_call_chain(pm_suspend_prepare); //用途一：有些设备需要在freeze进程之前就suspend；用途二：如果有些设备的reseym动作需要较多的延时么么resume的时候会在进程恢复之前，会阻止所有进程的恢复？更有甚者需要设备等待某个进程的数据才能resume; 
        //例子如下：drivers/video/fbdev/omap2/omapfb/dss/core.c
        error = suspend_freeze_processes(); //进程冻结，将用户进程和内核线程置于“可控”的暂停状态
</code></pre><p>在此对进程冻结进行展开描述</p>
<h3><span id="为什么需要进程冻结">为什么需要进程冻结</span></h3><ol>
<li>会破坏文件系统，在系统创建hibernate image到cpu down之间，如果有进程还在修改文件系统的内容，这将会导致系统恢复之后无法完全恢复文件系统；</li>
<li>有可能导致创建hibernation image失败，创建hibernation image需要足够的内存空间，这期间如果还有进程在申请内存，就可能导致创建失败</li>
<li>干扰设备的resume和suspend,在cpu down之前，device suspend期间，如果进程还在访问设备，尤其是访问竞争资源，就有可能引起设备suspend异常</li>
<li>有可能导致进程感知休眠。系统休眠的理想状态下是所有任务对休眠过程无感知，睡眠之后会自动恢复工作，有些进程，需要所有cpu online才能正常工作，如果进程不冻结，那么休眠过程中就会异常；    </li>
</ol>
<h3><span id="冻结进程的主要流程">冻结进程的主要流程</span></h3><pre><code>suspend_freeze_processes
——&gt;    freeze_processes()   -&gt; pm_freezing = true   
                         -&gt;try_to_freeze_tasks -&gt;  freeze_task -&gt;  fake_signal_wake_up(p); 冻结用户进程



-&gt;freeze_kernel_threads()  -&gt;pm_nosig_freezing = true 
                           -&gt;try_to_freeze_tasks -&gt; freeze_task -&gt;    freeze_workqueues_begin();   冻结workqueue;
                                                                    wake_up_state(p, task_interruptible); 冻结内核线程
</code></pre><p>冻结的对象：可以被调度执行的实体，包括用户进程，内核线程和workqueue.</p>
<h4><span id="1用户进程冻结流程">1.用户进程冻结流程</span></h4><p><strong>用户进程</strong>默认是可以被冻结的，<strong>借助信号处理机制</strong>,设置任务的tif_sigpending位，但不传递系统，然后唤醒任务；这样任务在返回用户态时就会进入信号处理流程，检查系统freeze状态，并做相应的处理；</p>
<pre><code>fake_signal_wake_up -&gt; signal_wake_up(p, 0) -&gt; signal_wake_up_state(t, resume ? task_wakekill : 0); 
                                                    -&gt; set_tsk_thread_flag(t, tif_sigpending);
</code></pre><p><strong>信号的处理时机</strong></p>
<p>理解信号异步机制的关键是信号的响应时机，我们对一个进程发送一个信号后，其实并没有硬中断发生，只是简单把信号挂载到目标进程的信号pending队列上去，信号真正得到执行的时机是进程执行完异常/中断返回到用户态的时刻；</p>
<p>让信号看起来是一个异步中断的关键是,正常的用户进程是会频繁的在用户态和内核态之间切换的（这种切换包括：系统调用，缺页异常，系统中断..）,所以信号能很快得到执行。这样也带来一个问题，内核进程是不响应信号的，除非它刻意的去查询。所以通常情况下我们无法通过kill命令去杀死一个内核进程；</p>
<p><strong>信号响应时机：</strong></p>
<p><img src="/2018/12/13/standby/kernel_suspend/信号响应时机.jpg" alt="信号响应时机"></p>
<pre><code>arch/arm64/kernel/signal.c    
do_notify_resume -&gt; do_signal(regs) -&gt; get_signal
                                            task_work_run
                                            try_to_freeze

                                    -&gt; handle_signal
</code></pre><h4><span id="2内核线程冻结">2.内核线程冻结</span></h4><p><strong>内核线程和workqueue</strong>默认是不能被冻结的，少数内核线程和workqueue在创建的时指定了freezable标志。这些任务需要对freeze状态进行判断，当系统进入freezing时，可以通过调用freezing来判断freezing状态，<strong>并主动调用</strong>，try_to_freeze进入冻结；</p>
<pre><code>代码范例如下：
static int autohotplug_thread_task(void *data)
{
    set_freezable();
    while (1) {
            if (freezing(current)) {
                    if (try_to_freeze())
                            continue;
            }    

            if (hotplug_enable)
                    autohotplug_governor_judge();

            set_current_state(task_interruptible);
            schedule();
            if (kthread_should_stop())
                    break;
            set_current_state(task_running);
    }    

    return 0;
}
</code></pre><h4><span id="3workqueue冻结">3.workqueue冻结</span></h4><p>work_queue通过max_active属性，<strong>如果max_active=0则不能入队新的work</strong>,所有的work延后执行；</p>
<pre><code>freeze_workqueues_begin -&gt;     workqueue_freezing = true; 
                            pwq_adjust_max_active(pwq); 
                        if (!freezable || !workqueue_freezing){
                                pwq-&gt;max_active = wq-&gt;saved_max_active;
                        } else {
                             pwq-&gt;max_active = 0;
                        }

schedule_work -&gt; queue_work -&gt; queue_work_on -&gt;
 __queue_work 
    ...
    如果还没有达到max_active,将work挂载到worklist
          if (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) {
                trace_workqueue_activate_work(work);
                pwq-&gt;nr_active++;
                worklist = &amp;pwq-&gt;pool-&gt;worklist;
                if (list_empty(worklist))
                        pwq-&gt;pool-&gt;watchdog_ts = jiffies;
       否则将work挂载到临时队列 pwq-&gt;delayed_works
            } else {
                work_flags |= work_struct_delayed;
                worklist = &amp;pwq-&gt;delayed_works;
            }                       
  ...
</code></pre><p><strong>需要注意事项：</strong></p>
<ol>
<li>workqueue的冻结只针对带有WQ_FREEZABLE;所以如果是schedule_work这种默认使用的是system_wq类型的workqueue冻结进程的时候并不会进行冻结；</li>
<li>对于schedule_delay_work的动作，如果休眠的时候不需要执行，则需要进行cancel_delayed_work_sync的动作，防止阻止系统休眠；    </li>
</ol>
<h3><span id="冻结进程何时被打断">冻结进程何时被打断</span></h3><p>进程怎么阻止休眠：无论通过wake_lock接口，__pm_stay_awake等，最终调用的都是wakeup_source_activate，都是增加inpr表示有事件在处理不准休眠；</p>
<pre><code>wakeup_source_activate
    /* increment the counter of events in progress. */
    cec = atomic_inc_return(&amp;combined_event_count);   也即解下来要讲的变量inpr

在系统休眠过程中：上层会判断cnt == saved_count, inpr == 0；底层也是如此
 bool pm_wakeup_pending(void)                                                                                     
 {                                                                                                                
     unsigned long flags;                                                                                     
     bool ret = false;                                                                                        

     spin_lock_irqsave(&amp;events_lock, flags);                                                                  
     printk(&quot;++%s %d++\n&quot;,__func__, events_check_enabled);                                                    
     if (events_check_enabled) {                                                                              
             unsigned int cnt, inpr;                                                                          

             split_counters(&amp;cnt, &amp;inpr);    
             用户空间还有内核都是判断这两个变量；如果写入的值和cnt不同，说明读写的过程中出现产生了events；
             inpr表示用唤醒事件在处理，这两种都会阻止系统休眠                                                                
             ret = (cnt != saved_count || inpr &gt; 0);                                                          
             events_check_enabled = !ret;                                                                     
             printk(&quot;+++%s cnt:%d saved_count:%d inpr:%d ret:%d++\n&quot;,__func__, cnt, saved_count, inpr, ret);  
     }                                                                                                        
     spin_unlock_irqrestore(&amp;events_lock, flags);                                                             

     if (ret) {                                                                                               
             pr_info(&quot;pm: wakeup pending, aborting suspend\n&quot;);                                               
             pm_print_active_wakeup_sources();                                                                
     }                                                                                                        

     return ret || pm_abort_suspend;                                                                          
 }
</code></pre><h1><span id="device_suspend设备休眠">device_suspend(设备休眠)</span></h1><pre><code>suspend_devices_and_enter
--&gt; platform_suspend_begin
    suspend_console();
    dpm_suspend_start(pmsg_suspend);
        --&gt;dpm_prepare(state);
        --&gt;dpm_suspend(state);
            device_suspend(dev);    
                --&gt;async_schedule(async_suspend, dev); 
                //在设备中如果通过device_enable_async_suspend设置过，async_schedule使设备走异步的休眠唤醒流程；
                --&gt;__device_suspend(dev, pm_transition, false);
                        dpm_watchdog_set//设置超时watchdog，若休眠时间过长，则打印打钱的设置和函数栈默认超时时间为120s

                --&gt;    dpm_run_callback(callback, dev, state, info);    
                        由于设备模型有bus、driver、device等多个层级，而suspend接口可能由任意一个层级实现。这里的优先顺序
                        是指，只要优先级高的层级注册了suspend，就会优先使用它，而不会使用优先级低的prepare。优先顺序为：dev-&gt;pm_domain-&gt;ops、dev-&gt;type-&gt;pm、dev-&gt;class-&gt;pm、dev-&gt;bus-&gt;pm、dev-&gt;driver-&gt;pm（这个优先顺序同样适用于其它callbacks）。 
                echo 1 &gt; /sys/power/pm_print_times //在每个设备发起休眠唤醒流程的时候就能打印出来
                --&gt; async_synchronize_full （等待所有异步动作都做完) 
</code></pre><h1><span id="platform关闭不需要唤醒的中断">platform（关闭不需要唤醒的中断）</span></h1><pre><code>suspend_enter(state, &amp;wakeup);
    --&gt;platform_suspend_prepare(state);        
       dpm_suspend_late(pmsg_suspend);
       platform_suspend_prepare_late(state);
       dpm_suspend_noirq(pmsg_suspend)
               --&gt;cpuidle_pause();
               device_wakeup_arm_wake_irqs();
                    如果设备具有唤醒功能(dev-&gt;power.can_wakeup,device_init_wake 的时候就会使能)那么设置唤醒标志(irqd_wakeup_state)
                    --&gt;enable_irq_wake-&gt;irq_set_irq_wake-&gt;set_irq_wake_real-&gt;irq_set_wake-&gt;sunxi_irq_set_wake 
                    --&gt;arisc_set_wakeup_source传递到cpus
                  suspend_device_irqs();
                    --&gt;没有唤醒标志的 enable_irq_wake,  request_irq(irq, xxx_isr, flag | IRQF_NO_SUSPEND`, xxx, xxx)的时候，此时中断会被清除,此时切断的是irq device和irq controller之间的联系
                        这两者的区别在于enable_irq_wake还会走到synchronize_irq(irq),等待中断处理完毕

              device_suspend_noirq(dev) //处理关闭中断后的事情    
       platform_suspend_prepare_noirq(state)            
</code></pre><h1><span id="cpus关闭no-bootcpu">cpus(关闭no bootcpu)</span></h1><pre><code>disable_nonboot_cpus() //关闭no boot cpu
    freeze_secondary_cpus(0)
            _cpu_down(cpu, 1, cpuhp_offline);
</code></pre><h1><span id="core关闭cpu中断通知arisc走休眠处理流程">core(关闭cpu中断，通知arisc走休眠处理流程)</span></h1><pre><code>arch_suspend_disable_irqs(); //此时关闭的是irq controller和cpu的联系，在这个时候中断便不能唤醒cpu了;
     local_irq_disable();
syscore_suspend();//主要调用sched_clock_suspend,timekeeping_suspend,irq_gc_suspend,fw_suspend,cpu_pm_suspend
          //echo Y &gt; /sys/module/kernel/parameters/initcall_debug 通过这个命令可以看到相关的调用
    suspend_ops-&gt;enter(state);    
        sunxi_suspend_enter//向小cpus传递电源相关参数
            arm_cpuidle_suspend
                 cpuidle_ops[cpu].suspend(index)
                    psci_cpu_suspend_enter
                        cpu_suspend(3, psci_suspend_finisher)
                    svc：psci_fn_cpu_suspend
</code></pre><h1><span id="arisc小cpu的休眠处理流程">arisc(小cpu的休眠处理流程)</span></h1><pre><code>extended_super_standby_entry(pmessage)
    esstandby_process_init(request, para, config) 
        dram进入自刷新；
        将系统相关的clk切换到低频状态
        将系统相关的电源关闭
    get_wakeup_src(para)
        轮询检测中断源
</code></pre><h1><span id="休眠唤醒流程">休眠唤醒流程</span></h1><p><img src="/2018/12/13/standby/kernel_suspend/suspend_resume_trace.jpg" alt="suspend_resume_trace">                         </p>
<h2><span id="思考题">思考题：</span></h2><p><strong>1：进行如下操作后</strong></p>
<p>echo 1 &gt; /sys/power/wake_lock</p>
<p>echo mem &gt; /sys/power/state</p>
<p><strong>此时系统能否休眠？？</strong></p>
<pre><code>能,events_check_enabled此时的值为false，故系统会直接进入休眠状态;只有上层程序在调用save_wakeup_count的时候，会去使能events_check_enabled，从这个层面讲，休眠的时候需不需要被唤醒事件打断，其实是看用户自身是否需要这种同步机制；
</code></pre><p>有正在处理的事件inpr，为什么还要cnt作为判断进入休眠唤醒的标志呢？</p>
<pre><code>一般而言inpr已经足够表示系统有事件在进行，不要进入休眠；引入这个条件笔者认为只是为了能更新该值，保证wakeup_event都能被统计到；
当cnt != save_cnt 
打印如下 last active wakeup source: axp22_wakeup_source；表明是上次是被谁影响到休眠
</code></pre><p><strong>2: 为什么即有request_irq(irq, xxx_isr, flag | IRQF_NO_SUSPEND, xxx, xxx)又有，enanle_irq_wake?</strong></p>
<pre><code>http://www.wowotech.net/forum/viewtopic.php?id=20
这里有相关的讨论，大意是
这两个方法，做的是同一件事情，都是控制“request line和irq controller之间的联系”。
IRQF_NO_SUSPEND是旧方法；
enable_irq_wake是新方法。
之有的driver都调用这两个接口，有两种可能：一是为兼容；而是不太理解，为保险起见，都调用。
从代码上看request的时候带的参数IRQF_OF_SUSPEND只能在内核休眠的时候起到阻止休眠的功能，而enable_irq_wake则可以在深度休眠后仍然能唤醒；
当休眠到core阶段的时候cpu的irq和fiq都已关闭，但仍保存着wakeup信号线，通过wakeup信号线唤醒从而唤醒cpu,当cpu中断使能开启后再响应中断
不建议使用IRQF_NO_SUSPEND的方式,原因有三个，一:对于电平触发的会在唤醒的是时候由于中断处理线程得不到调度导致pending存在,阻塞系统唤醒;
二:enable_irq_wake能通过disable_irq_wake的方式动态处理开关是否需要唤醒系统,
或者在probe的时候通过device_init_wakeup的方式添加设备唤醒系统的属性,这样无需调用enable_irq_wake就能使能设备休眠唤醒系统属性 
三：enable_irq_wake的设备，中断底半部处理函数即使调用sleep函数,系统仍会等到中断处理完成才睡眠不会漏处理
</code></pre><p><strong>3：怎么对休眠流程进行分解debug</strong></p>
<pre><code>内核在休眠的流程中加入了trace point可以根据这个去定位是哪个流程去定位哪个流程异常：
    echo 1 &gt; /sys/kernel/debug/tracing/events/power/suspend_resume/enable
    echo &gt; /sys/kernel/debug/tracing/trace //清空trace
    echo 1 &gt; /sys/kernel/debug/tracing/tracing_on
    按power键进入休眠的流程
    按power键唤醒
    cat  /sys/kernel/debug/tracing/trace
    查看在哪个流程就退出

如当怀疑休眠流程在device_suspend中挂死的；
可以echo devices &gt; /sys/power/pm_test
然后修改dpm_suspend设备的休眠流程，让其逐一进入休眠后退出，观察是哪个设备休眠唤醒后系统异常；
其他处于内核阶段的类似；

echo N &gt; /sys/module/printk/parameters/console_suspend //休眠的时候保持终端打开    
如果没有异常，那么可以怀疑是否由于cpus中dram进入自刷新后异常导致；或者系统电上下电导致；或者时钟频率不稳导致；    
在cpus中挂死，即走到arisc的休眠流程中,表现为串口log处于深度休眠，且无任何异常打印；
在重启的log中：
可以观察rtc寄存器的值：正常的值如下：
[371]rtc[0] value = 0x00000000
[374]rtc[1] value = 0x00000000
[377]rtc[2] value = 0x00000000
[380]rtc[3] value = 0x0000a101
[383]rtc[4] value = 0x00000000
[386]rtc[5] value = 0x00000000
此时观察rtc[3],查看相关代码定位挂死的地方
如怀疑dram导致的异常,可进行DRAM_CRC的校验，如下校验1G的空间
usage:
        echo  1 0x40000000 0x40000000 &gt; sys/devices/platform/soc/soc@03000000:arisc/dram_crc_paras

        1:           enable
        0x40024080:  dram crc start address
        0xf0000:     dram crc length(byte)
venus-a1:/ # cat ./sys/devices/platform/soc/soc@03000000:arisc/dram_crc_result
dram info:
 enable 0
  error 0
 total count 0
error count 0
src:40000000
len:0x100000
</code></pre><p><strong>4.查看内核锁</strong></p>
<pre><code>cat /sys/kernel/debug/wakeup_sources
如果debug下没有节点，需先进行挂载：mount -t debugfs none /mnt ,然后在mnt目录下查看
早期的linux版本，3.4
cat /proc/wakelocks    
</code></pre><p><strong>5.查看唤醒源</strong></p>
<pre><code>cat /sys/power/pm_wakeup_irq 这个会保存深度休眠的时候唤醒系统的中断号
配合 cat /proc/interrupts可获取当前唤醒系统的唤醒源是哪个
原理如下
在supend_device_irq的流程中能够wakeup系统的都会被置上IRQD_WAKEUP_ARMED的标志,然后就关闭中断;如果在中断处理流程里面的
会通过synchronize_irq等待中断线程处理完；
resume_irq的时候后重新enable_irq进入中断处理流程,通过pm_system_irq_wakeup标记第一次的唤醒源;
</code></pre><p><strong>6.项目经验总结</strong></p>
<pre><code>1. 硬件需确保电源信号稳定性；
2. 在项目开发过程中，休眠唤醒稳定性测试，在每次迭代的时候尽量做到一周进行一次多台机器休眠唤醒老化测试,测试老化的时候，应加大负载，如同时播放视频;
   以便增加问题的复现概率
</code></pre><h1><span id="参考资料">参考资料</span></h1><p><a href="http://www.wowotech.net/pm_subsystem/237.html" target="_blank" rel="noopener">linux进程冻结技术</a></p>
<p><a href="http://www.wowotech.net/pm_subsystem/suspend_and_resume.html" target="_blank" rel="noopener">Linux电源管理（6）_Generic PM之Suspend功能</a></p>
<p><a href="http://www.wowotech.net/irq_subsystem/workqueue.html" target="_blank" rel="noopener">Concurrency Managed Workqueue之（一）：workqueue的基本概念</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-cncrrc-mngd-wkq/index.html" target="_blank" rel="noopener">Linux 的并发可管理工作队列机制探讨</a></p>
<p><a href="http://kernel.meizu.com/linux-workqueue.html" target="_blank" rel="noopener">linux workqueue</a></p>
<p><a href="http://www.wowotech.net/irq_subsystem/irq_handle_procedure.html" target="_blank" rel="noopener">中断唤醒系统流程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/13/standby/android_standby/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/standby/android_standby/" itemprop="url">安卓休眠流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T00:07:09+00:00">
                2018-12-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/standby/" itemprop="url" rel="index">
                    <span itemprop="name">standby</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="安卓电源状态">安卓电源状态</span></h1><p>首先安卓将电源分为以下几种情况：</p>
<p><strong>1.sleep：</strong>休眠</p>
<pre><code>从代码看，安卓将系统的休眠原因分为以下几种：
goToSleepNoUpdateLocked
    GO_TO_SLEEP_REASON_DEVICE_ADMIN//Going to sleep due to device administration policy 
    GO_TO_SLEEP_REASON_TIMEOUT //Going to sleep due to screen timeout
    GO_TO_SLEEP_REASON_LID_SWITCH //Going to sleep due to lid switch 滑盖
    GO_TO_SLEEP_REASON_POWER_BUTTON //Going to sleep due to power button
    GO_TO_SLEEP_REASON_SLEEP_BUTTON //Going to sleep due to sleep button 头显的远近
    GO_TO_SLEEP_REASON_HDMI //Going to sleep due to HDMI standby
    GO_TO_SLEEP_REASON_ACCESSIBILITY//Going to sleep by an accessibility service request
    如果不是以上几种情况，则默认为应用导致的休眠：
    GO_TO_SLEEP_REASON_APPLICATION//Going to sleep by application request
</code></pre><p><strong>2.nap：</strong>进入屏保</p>
<pre><code>默认屏幕超时后进入休眠，如果希望进入的是屏保模式
则需要在overlay/frameworks/base/core/res/res/values/config.xml中将屏保模式打开
&lt;bool name=&quot;config_dreamsActivatedOnSleepByDefault&quot;&gt;true&lt;/bool&gt;    
</code></pre><p><strong>3.wakeup：</strong>唤醒</p>
<pre><code>wakeUpNoUpdateLocked
从以下状态中唤醒,reason不固定：
    WAKEFULNESS_ASLEEP:
    WAKEFULNESS_DREAMING：
    WAKEFULNESS_DOZING：
</code></pre><p><strong>4.shutdown：</strong>关机<br><strong>5.reboot：</strong>重启  </p>
<p>在此前的内核篇，我们讲到了用户层会去轮询查看是否有唤醒事件需要处理，如果没有则echo mem &gt; /sys/power/state,从而进入内核的休眠唤醒流程；所以在本篇我们主要将这两个流程是怎么衔接上的~</p>
<p><strong>由于通过调用api进行休眠唤醒的流程更为简单，所以我们看下老化apk是如何进行调用休眠唤醒的api，然后进行老化休眠唤醒实验的；</strong></p>
<h1><span id="老化休眠唤醒代码demo">老化休眠唤醒代码demo</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">休眠动作：</span><br><span class="line">单点击开始后，设置闹钟和走休眠流程： </span><br><span class="line">runSleepWakeUpTest()</span><br><span class="line">	mAlarmMgr.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() </span><br><span class="line">												+ (mSleepTime * 1000),</span><br><span class="line">												pendIntent);</span><br><span class="line"></span><br><span class="line">	standby();</span><br><span class="line">		pm.goToSleep(SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">唤醒动作：</span><br><span class="line"> onReceive</span><br><span class="line">	  </span><br><span class="line">	PowerManager pm = (PowerManager) this</span><br><span class="line">			   .getSystemService(Context.POWER_SERVICE);</span><br><span class="line">	if (getAndroidSDKVersion() &gt;= 17) &#123;</span><br><span class="line">	      pm.wakeUp(SystemClock.uptimeMillis());</span><br><span class="line">	</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		   pm.userActivity(SystemClock.uptimeMillis(), false);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从调用流程可以看到就是不断的调用goToSleep,然后设置一个闹钟，当闹钟来临的时候唤醒系统;</p>
<p><strong>framework相关代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">core/java/android/os/PowerManager.java</span><br><span class="line">public void goToSleep(long time) &#123;</span><br><span class="line">    	goToSleep(time, GO_TO_SLEEP_REASON_APPLICATION, 0);    </span><br><span class="line">	&#125;</span><br><span class="line">  	</span><br><span class="line">./services/core/java/com/android/server/power/PowerManagerService.java</span><br><span class="line">public void goToSleep(long eventTime, int reason, int flags) &#123;</span><br><span class="line">    if (eventTime &gt; SystemClock.uptimeMillis()) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;event time must not be in the future&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">	goToSleepInternal(eventTime, reason, flags, uid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void goToSleepInternal(long eventTime, int reason, int flags, int uid) &#123;</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (goToSleepNoUpdateLocked(eventTime, reason, flags, uid)) &#123;</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="sleep流程">sleep流程</span></h1><p>当屏幕超时，按power键休眠，和应用主动调goToSleep；无论是哪种方式，如果系统启动没有异常，都会走到PowerManagerService的核心函数，<strong>updatePowerStateLocked</strong>；按照安卓注释，将updatePowerStateLocked 分为五个阶段，我们也按照五个阶段对该函数的功能进行讲解；</p>
<p><strong>Phase 0: Basic state updates</strong></p>
<pre><code>1.USB插播亮屏入口点
 //如果需要插拔事件不影响到屏幕的亮灭，在overlay/frameworks/base/core/res/res/values/config.xml下
 //修改&lt;bool name=&quot;config_unplugTurnsOnScreen&quot;&gt;true&lt;/bool&gt;从字面意思貌似是拔出的时候不亮屏；
 //mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(                                                                                                                                               
            com.android.internal.R.bool.config_unplugTurnsOnScreen);//从这里就能完整看到这个配置的用途，插拔都会影响到屏幕

2.更新低电量模式        
当电池电量状态发生变化的时候，才能调到该方法
updateIsPoweredLocked(mDirty);

判断系统是否在setting中设置了充电时保持屏幕亮屏
updateStayOnLocked(mDirty);

updateScreenBrightnessBoostLocked(mDirty);  
</code></pre><p><strong>Phase 1: Update wakefulness</strong></p>
<p>wakefulness,安卓将休眠唤醒的电源状态分为四个：  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>状态介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>WAKEFULNESS_ASLEEP</td>
<td>设备处于sleep状态，只能被wakeUp函数唤醒，屏幕会被关闭，设备先进入doze状态</td>
</tr>
<tr>
<td>WAKEFULNESS_AWAKE</td>
<td>设备处于awake状态，可通过goToSleep的接口将设备置于休眠状态，当用户超时时间到了设备将开始dreaming或者进入休眠流程  </td>
</tr>
<tr>
<td>WAKEFULNESS_DREAMING</td>
<td>设备处于dreaming状态，会被wakeUp唤醒，当dreaming时间结束或者</td>
</tr>
<tr>
<td>WAKEFULNESS_DOZING</td>
<td>打盹</td>
</tr>
</tbody>
</table>
<pre><code>// Loop because the wake lock and user activity computations are influenced
// by changes in wakefulness. 
//此循环只会循环两次，然后就退出；
for (;;) {
    updateWakeLockSummaryLocked(dirtyPhase1);
        getWakeLockSummaryFlags(wakeLock);
        adjustWakeLockSummaryLocked(mWakeLockSummary);
    updateUserActivitySummaryLocked(now, dirtyPhase1);
    if (!updateWakefulnessLocked(dirtyPhase1)) {
                 break;  
     }           
 }
</code></pre><p>1.<strong>updateWakeLockSummaryLocked(dirtyPhase1);</strong> ；</p>
<p><strong>简单先介绍安卓的锁：</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>属性</th>
<th>功能介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>PARTIAL_WAKE_LOCK</td>
<td>WAKE_LOCK_CPU</td>
<td>保持CPU运行，屏幕和键盘灯允许关闭。用户按power键之后，屏幕和键盘灯会关闭，CPU keep on，直到所有该类型所被释放</td>
</tr>
<tr>
<td>FULL_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT  WAKE_LOCK_BUTTON_BRIGH</td>
<td>保证屏幕和键盘灯亮（at full brightness）。用户按power键之后，CPU和屏幕键盘灯都会被关闭</td>
</tr>
<tr>
<td>SCREEN_BRIGHT_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT</td>
<td>保证屏幕亮（full brightness），键盘灯允许关闭。用户按power键之后，CPU和屏幕都会被关闭</td>
</tr>
<tr>
<td>SCREEN_DIM_WAKE_LOCK</td>
<td>WAKE_LOCK_SCREEN_BRIGHT</td>
<td>保证屏幕亮（full brightness），键盘灯允许关闭。用户按power键之后，CPU和屏幕都会被关闭</td>
</tr>
<tr>
<td>PROXIMITY_SCREEN_OFF</td>
<td>PROXIMITY_SCREEN_OFF</td>
<td>pSensor导致的灭屏情况下系统不会进入休眠，正常情况下不影响系统休眠</td>
</tr>
<tr>
<td>DOZE_WAKE_LOCK</td>
<td>WAKE_LOCK_DOZE</td>
<td>使屏幕进入low power状态，允许cpu挂起。只有在电源管理进入doze模式时生效</td>
</tr>
<tr>
<td>DRAW_WAKE_LOCK</td>
<td>WAKE_LOCK_DRAW</td>
<td>保持设备awake状态已完成绘制事件，只在doze模式下生效</td>
</tr>
</tbody>
</table>
<p>该函数的主要作用为，遍历申请的所有锁，根据当前mWakefulness的状态(asleep,dozing,wake，dream)，过滤不需要的锁,如DOZE模式下过滤<strong>WAKE_LOCK_SCREEN_BRIGHT</strong>，<strong>WAKE_LOCK_SCREEN_DIM</strong>，<strong>WAKE_LOCK_BUTTON_BRIGHT</strong>，而ASLEEP模式下在基础上过滤<strong>WAKE_LOCK_PROXIMITY_SCREEN_OFF</strong>,在Dream模式下会添加<strong>WAKE_LOCK_CPU</strong>.</p>
<p>2.<strong>updateUserActivitySummaryLocked(now, dirtyPhase1);</strong></p>
<p>mUserActivitySummary的种类如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>类型介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER_ACTIVITY_SCREEN_BRIGHT</td>
<td>点亮屏幕</td>
</tr>
<tr>
<td>USER_ACTIVITY_SCREEN_DIM</td>
<td>屏幕变暗</td>
</tr>
<tr>
<td>USER_ACTIVITY_SCREEN_DREAM</td>
<td>屏保模式</td>
</tr>
</tbody>
</table>
<pre><code>这里有三个时间参数：
sleepTimeout:设备完全休眠的时间，该值可以理解为保持唤醒或屏保的最大值或者上限，并且该值要大 
             Settings.System.SCREEN_OFF_TIMEOUT,默认为-1；表示禁用此功能项；
screenOffTimeoutSetting:表示设备在一段不活动进入睡眠或者屏保的时间，也称为用户超时时间，但屏幕不一定关闭，可能进入屏保
screenDimDuration 亮屏后不操作，多久变暗；
根据这三个时间参数计算nextTimeout的时间：
         scheduleUserInactivityTimeout(nextTimeout);
</code></pre><p>故该函数的主要作用为，更新用户活动时间，当设备和用户有交互的时，都会根据当前时间和休眠时长，dim时长，所处状态而计算下次休眠的时间，从而完成活动超时时的操作，如由亮屏进入Dim的时长，Dim到灭屏的时长，亮屏到屏保的时长；</p>
<p>3.<strong>updateWakefulnessLocked</strong></p>
<pre><code>if (shouldNapAtBedTimeLocked()) {                                            
changed = napNoUpdateLocked(time, Process.SYSTEM_UID);
    --&gt;mSandmanSummoned = true;
       setWakefulnessLocked(WAKEFULNESS_DREAMING, 0);
       --&gt;mNotifier.onWakefulnessChangeStarted(wakefulness, reason);                     
 } else {                                                                      
changed = goToSleepNoUpdateLocked(time,                                   
        PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, 0, Process.SYSTEM_UID);  
       --&gt; mSandmanSummoned = true;
           setWakefulnessLocked(WAKEFULNESS_DOZING, reason);
           --&gt;mNotifier.onWakefulnessChangeStarted(wakefulness, reason); 

 }                                                                             
</code></pre><p>该函数的主要作用在与更新电源状态；</p>
<p><strong>Phase2:Lock profiles that became inactive/not kept awake.</strong></p>
<pre><code>updateProfilesLocked(now); //估计是cts的时候使用，这个不再赘述
</code></pre><p><strong>Phase 3: Update display power state.</strong></p>
<pre><code>updateDisplayPowerStateLocked(dirtyPhase2); 
--&gt;mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked(); 
--&gt;requestPowerState
    --&gt;return mDisplayPowerController.requestPowerState(request,waitForNegativeProximity);
        --&gt;requestPowerState
            --&gt;sendUpdatePowerStateLocked
                --&gt;Message msg = mHandler.obtainMessage(MSG_UPDATE_POWER_STATE);
                    mHandler.sendMessage(msg);
handleMessage(Message msg)
   --&gt;updatePowerState();
      --&gt;animateScreenStateChange
        --&gt;setScreenState
        --&gt;mPowerState.setScreenState(state);(DPC)
            --&gt;scheduleScreenUpdate--&gt;postScreenUpdateThreadSafe--&gt;setState-&gt;mLock.notifyAll
                --&gt;mBlanker.requestDisplayState(DPS)
            --&gt;callbacks.onDisplayStateChange(state)  --&gt;根据亮灭屏走PowerManagerService enable/disable autosuspend
            --&gt;requestGlobalDisplayStateInternal(state, brightness=0) --&gt;mTempDisplayStateWorkQueue.get(i).run()(DMS)
            --&gt;SurfaceControl.setDisplayPowerMode(LDA)

        --&gt;blockScreenOn 在亮屏的流程里面监听窗口是否绘制完成，
           是的话重新发起updatePowerState,设置mColorFadeLevel为1；此时才会去设置背光，这时候对于用户来说屏幕才是最终的亮了
           否的话此时的背光值一直会为0；


        --&gt;mWindowManagerPolicy.screenTurningOff(mPendingScreenOffUnblocker)
        在灭屏的同时还发起了activity的pause流程
        --&gt;updateScreenOffSleepToken
        --&gt;acquireSleepToken
        --&gt;updateSleepIfNeededLocked
        --&gt;goingToSleepLocked
        --&gt;checkReadyForSleepLocked
        --&gt;putStacksToSleepLocked
        --&gt;goToSleepIfPossible
        --&gt;startPausingLocked
        --&gt;schedulePauseAcvity --&gt; sendMessage
        --&gt;handleMessage --&gt;handlePauseActivity--&gt;performPauseActivity--&gt;performPauseActivityIfNeed
        --&gt;callActivityOnPause --&gt;activity.performPause--&gt; onPause
        唤醒的时候应用resume的流程
        ActivityStackSupervisor.java
        SleepTokenImpl.release
        --&gt;removeSleepTokenLocked
        --&gt;updateSleepIfNeededLocked
        --&gt;applySleepTokensLocked
        --&gt;resumeFocusedStackTopActivityLockedi
        --&gt;resumeTopActivityUncheckedLocked
        --&gt;resumeTopActivityInnerLocked
</code></pre><p>函数作用：决策屏幕的量灭状态</p>
<pre><code>如果当前是WAKEFULNESS_ASLEEP状态，直接设置屏幕为POLICY_OFF

如果包含以下一种状态，就设置屏幕为POLICY_BRIGHT

1.mWakeLockSummary 如果有 WAKE_LOCK_SCREEN_BRIGHT类型的wakeLock 

2.mUserActivitySummary 屏幕状态为USER_ACTIVITY_SCREEN_BRIGHT

3.当前系统未启动完成

4.当前处于最大屏幕亮度

可以看出屏幕的状态和前面设置的wakeLock，stayon,userActivity，screenBrightness等有关
</code></pre><p><strong>Phase 4: Update dream state (depends on display ready signal).</strong>        </p>
<pre><code>updateDreamLocked(dirtyPhase2, displayBecameReady);
--&gt;scheduleSandmanLocked();
    --&gt;if (!mSandmanScheduled) {
         Message msg = mHandler.obtainMessage(MSG_SANDMAN);
      }
</code></pre><p>函数作用：决定是否进入屏保状态</p>
<p><strong>Phase 5: Send notifications, if needed.</strong></p>
<pre><code>finishWakefulnessChangeIfNeededLocked();
</code></pre><p>函数作用：发出wakefulness发生改变的通知</p>
<p><strong>Phase 6: Update suspend blocker.</strong></p>
<pre><code>// Because we might release the last suspend blocker here, we need to make sure
// we finished everything else first!  
updateSuspendBlockerLocked(); 
    --&gt;needWakeLockSuspendBlocker = ((mWakeLockSummary &amp; WAKE_LOCK_CPU) != 0);//根据是否有CPU的wakelock，来决定cpu是否保持唤醒
    --&gt;needDisplaySuspendBlockerLocked//根据前面屏幕的状态，屏幕是否需要亮屏，来决定是否需要持持有屏幕的锁             
</code></pre><p>函数作用：进行锁的申请和释放</p>
<p>分析完整个函数的调用流程，依然找不到怎么跟内核休眠的流程衔接起来；那么安卓是什么是否才会去调用内核休眠流程对接起来的？原来安卓在上面的函数调到灭屏的接口时候，才会去使能autosuspend的流程；想想也没有什么毛病，毕竟对于用户来说灭屏时标识着系统要走到休眠的标志；</p>
<p>代码流程如下：</p>
<pre><code>onDisplayStateChange
--&gt;if (state == Display.STATE_OFF) {
    if (!mDecoupleHalAutoSuspendModeFromDisplayConfig) {
           setHalInteractiveModeLocked(true);
    }
    }
 nativeSetAutoSuspend(enable);
    enabelAutosuspend
        suspendControl-&gt;enableAutoSuspend 使能autoSuspend进程，进程会一直检测系统是否无锁
        gSuspendBlocker-&gt;release释放锁
对应的灭屏disable的流程
    disableAutoSuspend
    suspendHal-&gt;acquireWakeLock(WakeLockType:PARTIAL,&quot;PowerManager.SuspendLockout&quot;);所以一旦亮屏我们都会在内核的wake_lock节点看到这个锁,当然等到安卓把这个锁放在上层申请
    的话就看不到了 
</code></pre><p>为了呼应上次内核篇上讲的安卓等待的时机，我们在这里把读写wakeup count内核的的相关操作也po出来；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ReadFdToString(wakeup_count_fd, &amp;wakeup_count)</span><br><span class="line">	bool pm_get_wakeup_count(unsigned int *count, bool block)    </span><br><span class="line">	&#123;                                                            </span><br><span class="line">	    unsigned int cnt, inpr;                                  </span><br><span class="line">	                                                             </span><br><span class="line">	    if (block) &#123;                                             </span><br><span class="line">	        DEFINE_WAIT(wait);                                   </span><br><span class="line">	                                                             </span><br><span class="line">	        for (;;) &#123;                                           </span><br><span class="line">	            prepare_to_wait(&amp;wakeup_count_wait_queue, &amp;wait, </span><br><span class="line">	                    TASK_INTERRUPTIBLE);                     </span><br><span class="line">	            split_counters(&amp;cnt, &amp;inpr);                     </span><br><span class="line">	            if (inpr == 0 || signal_pending(current))        </span><br><span class="line">	                break;                                       </span><br><span class="line">	                                                             </span><br><span class="line">	            schedule();                                      </span><br><span class="line">	        &#125;                                                    </span><br><span class="line">	        finish_wait(&amp;wakeup_count_wait_queue, &amp;wait);        </span><br><span class="line">	    &#125;                                                        </span><br><span class="line">	                                                             </span><br><span class="line">	    split_counters(&amp;cnt, &amp;inpr);                             </span><br><span class="line">	    *count = cnt;                                            </span><br><span class="line">	    return !inpr;                                            </span><br><span class="line">	&#125;</span><br><span class="line">可以看到在读函数里面也会去判断是否有唤醒事件在处理，如果有唤醒事件那么就会不断的阻塞在获取进程当中；</span><br><span class="line"></span><br><span class="line">WriteStringToFd(wakeup_count, wakeup_count_fd)</span><br><span class="line">	bool pm_save_wakeup_count(unsigned int count)     </span><br><span class="line">	&#123;                                                 </span><br><span class="line">	    unsigned int cnt, inpr;                       </span><br><span class="line">	    unsigned long flags;                          </span><br><span class="line">	                                                  </span><br><span class="line">	    events_check_enabled = false;                 </span><br><span class="line">	    spin_lock_irqsave(&amp;events_lock, flags);       </span><br><span class="line">	    split_counters(&amp;cnt, &amp;inpr);                  </span><br><span class="line">	    if (cnt == count &amp;&amp; inpr == 0) &#123;              </span><br><span class="line">	        saved_count = count;                      </span><br><span class="line">	        events_check_enabled = true;              </span><br><span class="line">	    &#125;                                             </span><br><span class="line">	    spin_unlock_irqrestore(&amp;events_lock, flags);  </span><br><span class="line">	    return events_check_enabled;                  </span><br><span class="line">	&#125;</span><br><span class="line">可以看到在写函数中，呼应到了我们内核篇中，当判断是否save_count == wakeup_count &amp;&amp; inpr==0这两个判断为没有唤醒事件，之后就开始写相关的节点，</span><br><span class="line"></span><br><span class="line">success = WriteStringToFd(sleep_state, state_fd);//echo mem &gt; /sys/power/state 发起内核进入休眠流程；</span><br></pre></td></tr></table></figure>
<p>总之，当安卓灭屏后，才会使能autosuspend不断轮询是否有锁也即唤醒事件，没有才会下发mem到写到内核节点state中；</p>
<h1><span id="安卓的唤醒流程">安卓的唤醒流程</span></h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputManagerService interceptKeyBeforeQueueing</span><br><span class="line">InputMonitor        interceptKeyBeforeQueueing</span><br><span class="line">PhoneWindowManager  interceptKeyBeforeQueueing</span><br><span class="line">		    inputceptPowerKeyDown</span><br><span class="line">		    wakeUpFromPowerKey</span><br><span class="line">		    wakeUp</span><br><span class="line">PowerManager	    wakeUp</span><br><span class="line">PowerManagerService wakeUp</span><br></pre></td></tr></table></figure>
<h1><span id="android-r上的变更">android R上的变更</span></h1><p>androidR上，谷歌说要弃用/sys/power/wake_lock节点；安卓此前申请锁的流程在hardware/libhardware_legacy/power.cpp;原理就是去往wake_lock节点写值;<br>现在的话想将这个流程放在system/hardware/interfaces/suspend中进行实现；</p>
<p>在这里只能说谷歌终于想通了要把这套放在用户层，毕竟曾经为了wake_lock,一直在争吵，最后还是被谷歌给干进内核，现在的话又抽出来放在用户层里面；具体细节可以参照这篇文章<a href="http://www.wowotech.net/pm_subsystem/wakelocks.html" target="_blank" rel="noopener">Linux电源管理</a></p>
<p>谷歌列举这样的好处是：</p>
<ol>
<li>减少对内核的依赖</li>
<li>在没有debugfs的时候用户层仍有能力去debug和log suspend blocks</li>
<li>当进程消亡的时候可以进行锁通过binder的管理进行释放 dangling wake locks</li>
</ol>
<p>通过mSuspendCounter去统计当前持锁的数量，当mSuspendCounter为0的时候，说明上层持锁为0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void SystemSuspend::initAutosuspend() &#123;                                                             </span><br><span class="line">    std::thread autosuspendThread([this] &#123;                                                          </span><br><span class="line">        while (true) &#123;                                                                              </span><br><span class="line">            std::this_thread::sleep_for(mSleepTime);   //如果失败了，会更改autosuspend的时间，100ms~1min                                             </span><br><span class="line">            lseek(mWakeupCountFd, 0, SEEK_SET);                                                     </span><br><span class="line">            const string wakeupCount = readFd(mWakeupCountFd);                                      </span><br><span class="line">            if (wakeupCount.empty()) &#123;                                                              </span><br><span class="line">                PLOG(ERROR) &lt;&lt; &quot;error reading from /sys/power/wakeup_count&quot;;                        </span><br><span class="line">                continue;                                                                           </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">                                                                                                    </span><br><span class="line">            auto counterLock = std::unique_lock(mCounterLock);                                      </span><br><span class="line">            mCounterCondVar.wait(counterLock, [this] &#123; return mSuspendCounter == 0; &#125;);//申请锁的时候mSuspendCounter会增加；释放的时候mSuspendCounter会减少            </span><br><span class="line">            // The mutex is locked and *MUST* remain locked until we write to /sys/power/state.     </span><br><span class="line">            // Otherwise, a WakeLock might be acquired after we check mSuspendCounter and before we </span><br><span class="line">            // write to /sys/power/state.                                                           </span><br><span class="line">                                                                                                    </span><br><span class="line">            if (!WriteStringToFd(wakeupCount, mWakeupCountFd)) &#123;                                    </span><br><span class="line">                PLOG(VERBOSE) &lt;&lt; &quot;error writing from /sys/power/wakeup_count&quot;;                      </span><br><span class="line">                continue;                                                                           </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">            bool success = WriteStringToFd(kSleepState, mStateFd);                                  </span><br><span class="line">            counterLock.unlock();                                                                   </span><br><span class="line">                                                                                                    </span><br><span class="line">            if (!success) &#123;                                                                         </span><br><span class="line">                PLOG(VERBOSE) &lt;&lt; &quot;error writing to /sys/power/state&quot;;                               </span><br><span class="line">            &#125;                                                                                       </span><br><span class="line">                                                                                                    </span><br><span class="line">            mControlService-&gt;notifyWakeup(success);                                                 </span><br><span class="line">                                                                                                    </span><br><span class="line">            updateSleepTime(success);                                                               </span><br><span class="line">        &#125;                                                                                           </span><br><span class="line">    &#125;);                                                                                             </span><br><span class="line">    autosuspendThread.detach();                                                                     </span><br><span class="line">    LOG(INFO) &lt;&lt; &quot;automatic system suspend enabled&quot;;                                                </span><br><span class="line">&#125;</span><br><span class="line">关机充电判断休眠唤醒原理大同小异 </span><br><span class="line">	system/core/libsuspend/autosuspend.c</span><br><span class="line">	int autosuspend_enable(void)</span><br><span class="line">	&#123;</span><br><span class="line">    	autosuspend_init();</span><br><span class="line">			autosuspend_ops = autosuspend_wakeup_count_init(); </span><br><span class="line">    	autosuspend_ops-&gt;enable();   </span><br><span class="line">			autosuspend_wakeup_count_enable（）</span><br><span class="line">	&#125;</span><br><span class="line">	system/core/libsuspend/autosuspend_wakeup_count.cpp</span><br><span class="line">	autosuspend_wakeup_count_enable（）</span><br><span class="line">		autosuspend_init();</span><br><span class="line">			创建一个进程：suspend_thread_func 这个进程主要就是用来做轮询的动作</span><br><span class="line">		sem_post(&amp;suspend_lockout);</span><br><span class="line">	suspend_thread_func</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		 if (!ReadFdToString(wakeup_count_fd, &amp;wakeup_count)) &#123; //读取wakeup count值，如果成功，将读取的值回写，否则说明正在处理wakeup events,continue</span><br><span class="line">			continue; </span><br><span class="line">		 &#125;</span><br><span class="line">		 int ret = sem_wait(&amp;suspend_lockout);//通过信号量来控制这个流程是否要继续走下去，当disable的时候信号量为0，进程会阻塞在这里等待；</span><br><span class="line">		 if (WriteStringToFd(wakeup_count, wakeup_count_fd)) &#123; //回写后，判断返回值是否成功，如果不成功（说明读写过程中产生了wakeup events）,继续读，写，直到成功。成功后，可以触发电源状态切换</span><br><span class="line">			   success = WriteStringToFd(sleep_state, state_fd);                    </span><br><span class="line">		&#125;</span><br><span class="line">		ret = sem_post(&amp;suspend_lockout);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1><span id="其他">其他</span></h1><p><strong>如何设置安卓休眠超时时间？</strong></p>
<pre><code>settings get system screen_off_timeout
settings put system screen_off_timeout 2147483647 //设置永不休眠 
</code></pre><p><strong>设置屏保命令</strong><br>    settings put secure screensaver_activate_on_sleep 1 打开屏保<br><strong>设置插入适配器后不休眠</strong><br>    settings put global stay_on_while_plugged_in 1<br><strong>安卓系统不休眠debug </strong></p>
<pre><code>查看上层有没有释放锁
    dumpsys power | grep -Hrsn &apos;LOCK&apos;
PARTIAL_WAKE_LOCK              &apos;messaging_service_start_wakelock&apos; 
查看active_since这一项，看哪个锁不为0
      cat /sys/kernel/debug/wakeup_sources

上层传向底层的锁
cat /sys/power/wake_lock
当这几步查找后都没有对应的锁时，可以通过/sys/power/pm_test结点,操作设备进入对应的休眠阶段，详见linux休眠篇章
</code></pre><p><strong>进入深度休眠后被唤醒问题debug</strong></p>
<pre><code>一般而言，平台会提供深度休眠后如何查看系统唤醒源，如全志平台的查看方式为
    一：休眠的时候不关闭终端
    echo N &gt; /sys/module/printk/parameters/console_suspend
    二：唤醒后查看对应的唤醒源
    查看唤醒时候打印:
        platform wakeup, standby wakesource is:0x10000
    在allwinner对应的pm.h里面就可以看到对应的唤醒源编号，如linux4.9的在driver/soc/sunxi/pm.h 
    其他版本可以直接搜索关键字找到对应的唤醒源编号；
        #define CPUS_WAKEUP_DESCEND     (1&lt;&lt;16)
    而CPUS的GPIO一般是WIFI中断管脚在连接，故此时可以断开wifi连接查看系统唤醒是否依然异常
另外如果当log出现为闹钟唤醒：
    platform wakeup, standby wakesource is:0x100000
    查看对应唤醒源编号
    #define CPUS_WAKEUP_ALM0        (1&lt;&lt;20)
这种情况下我们一般需要通过去查看到底是哪个应用去唤醒系统的：这个时候我们可以借助这个应用 BetterBatteryStats2.0
    1.下载地址：
    http://cn.apkhere.com/app/com.asksven.betterbatterystats
    安装该软件：
    2.adb install com.asksven.betterbatterystats_2.2.2.0_paid-www.apkhere.com.apk
    3.获取权限：
    adb -d shell pm grant com.asksven.betterbatterystats android.permission.BATTERY_STATS
    4.若依然不可以：
    setenforce 0：取消selinux
    getenforce 查看是否为安全模式 Permissive 则是非安全；
    观察各项参数：
</code></pre><p><strong> rtc闹钟设置与查看 </strong></p>
<pre><code>venus-a3:/ # cat /proc/driver/rtc
rtc_time        : 05:44:49
rtc_date        : 2019-04-26
alrm_time       : 00:00:00
alrm_date       : 1970-01-01
alarm_IRQ       : no
alrm_pending    : no
update IRQ enabled      : no
periodic IRQ enabled    : no
periodic IRQ frequency  : 1
max user IRQ frequency  : 64
24hr            : yes

设置当前时间+100000后唤醒
venus-a3:/ # echo +100000 &gt; /sys/devices/platform/soc/rtc/rtc/rtc0/wakealarm
venus-a3:/ # cat /proc/driver/rtc
rtc_time        : 05:47:15
rtc_date        : 2019-04-26
alrm_time       : 09:33:52
alrm_date       : 2019-04-27
alarm_IRQ       : yes
alrm_pending    : no
update IRQ enabled      : no
periodic IRQ enabled    : no
periodic IRQ frequency  : 1
max user IRQ frequency  : 64
24hr            : yes

echo 0取消

查看闹钟应用设置闹钟：
venus-a3:/ # settings list system | grep  next
       next_alarm_formatted=Wed 11:50 AM
</code></pre><p><strong>怎么捕捉休眠唤醒的systrace</strong><br>    休眠前<br>    atrace –async_start -b 8192 -o /data/trace2.dat gfx view wm am power<br>    唤醒后<br>    atrace –async_stop</p>
<h1><span id="参考资料">参考资料</span></h1><p><a href="https://www.cnblogs.com/dyufei/p/8018016.html" target="_blank" rel="noopener">Android7.0 PowerManagerService 之亮灭屏（二） PMS 电源状态管理updatePowerStateLocked（）</a></p>
<p><a href="https://www.jianshu.com/p/b40e1b61e6d2" target="_blank" rel="noopener">Android 保持屏幕常亮的几种方法</a></p>
<p><a href="https://blog.csdn.net/Gaugamela/article/details/52838654" target="_blank" rel="noopener">Android7.0 PowerManagerService(3)核心函数updatePowerStateLocked的主要流程</a></p>
<p><a href="https://blog.csdn.net/fu_kevin0606/article/details/54408094" target="_blank" rel="noopener">Android7.0 PowerManagerService亮灭屏分析(一)</a></p>
<p><a href="https://blog.csdn.net/ysh06201418/article/details/41849191" target="_blank" rel="noopener">wakelock介绍</a></p>
<p><a href="https://jasper-1024.github.io/2017/08/19/linux%E7%AC%94%E8%AE%B0%E2%80%94rtc%E5%AD%90%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">linux笔记–rtc子系统</a></p>
<p><a href="http://ddrv.cn/a/102265" target="_blank" rel="noopener">Android7.0亮屏流程分析</a></p>
<p><a href="https://cronusliang.me/android/2019/06/10/%E9%94%81%E5%B1%8F%E5%88%86%E6%9E%90(9.0" target="_blank" rel="noopener">锁屏分析</a>/)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/17/cpu/arm体系架构的发展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongka">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="知识总结">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/17/cpu/arm体系架构的发展/" itemprop="url">ARM体系架构概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-17T14:54:00+00:00">
                2018-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cpu/" itemprop="url" rel="index">
                    <span itemprop="name">cpu</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1><span id="arm体系架构的发展">ARM体系架构的发展</span></h1><p>本文将从以下几点去展开介绍arm体系架构的发展：</p>
<ol>
<li>指令集架构</li>
<li>arm公司的发展历史以及授权模式</li>
<li>arm的体系架构 </li>
</ol>
<h1><span id="arm公司的发展历史">arm公司的发展历史</span></h1><p>arm的发展历程在此文章讲的非常详细，故不再赘述<a href="http://www.eefocus.com/mcu-dsp/409079/r0" target="_blank" rel="noopener">一文带你了解ARM的发展历程</a></p>
<h2><span id="arm授权模式">arm授权模式</span></h2><p>在传统PC领域，半导体有两种路子可以走，一种是Intel这种，<strong>从头到尾一条龙，架构和芯片设计，生产一律不靠任何人</strong>； 这样做需要极其雄厚，全方位的实力做保障，得有钱，有人，有技术，在半导体技术日益复杂的今天，能这么做屈指可数；好处就是利润率比较高，想卖多少钱就多少；当然技术上得做到领先甚至于垄断的地位优势才比较明显；</p>
<p>另外一种则无工厂模式（Fabless）,<strong>NVIDIA,AMD,这类企业都是自己设计芯片，制造交给代工厂，比如台积电，联电，GlobalFoundries,三星电子</strong>。好处很明显，负担轻，但是在半导体这种工艺在功耗与性能中扮演重要角色的行业，你设计出来的是否能设计出来，怎么设计出来，很大程度看代工厂的能耐；幸好这些代工厂也十分给力，不断的逼近物理极限；使得AMD最近也能慢慢的赶上挤牙膏的Intel;</p>
<p>arm就不一样了，它不制造，不销售芯片，只是自己设计IP,包括指令集，微处理器，GPU,总线，然后谁要的话就买arm的授权；授权模式分为此三种：</p>
<h3><span id="处理器授权">处理器授权</span></h3><p>ARM设计好一颗CPU或者GPU，armv7架构对应的IP为Cortex-A5/A7/A9/A12/A15/A17这几个核心架构，对应armv8-A就有Cortext-A35/A53/A57/A72/A73;ARMv8.2A指令集：Cortext-A55/A75;然后授权卖给伙伴，买下它们后，只能按照图纸实现，能发挥的不多，如何实现就比较随便，如配置哪些模块，几个核心，多少缓存，多高频率，什么工艺，谁来代工等等；</p>
<p>如果想优化，但是技术有限，那么可以买arm的处理器优化包/物理IP包授权（POP）<br>如果只是想更快速搞出产品，那么更干脆了，arm已经帮你制定好代工厂处理器类型和工艺了；<br>代表商家有联发科，展讯，联芯，全志，瑞芯微，炬力等；这些设计公司获得的是软核或者这点硬核授权，通过购买的CPU核，与GPU核，以及通过一定的流程，集成出SOC；</p>
<p>购买处理器授权的本质上就大同小异了，可以做出差异化的只能在一些IP上做出差异化；</p>
<h3><span id="架构指令授权">架构/指令授权</span></h3><p>这种授权方式价格比较贵，为防止碎片化的情况出现还有可能处于技术上的保护，arm禁止对指令集进行修改或者添加，但其他公司是否确切遵守了，这个就不得而知了；总之这种授权需要具有非常强的技术实力，也不过15家，如我们熟知的高通，苹果，三星，华为等公司；</p>
<p>除了版税，那些购买了arm IP授权的，还需要为每一个芯片支付版税；</p>
<p>在这里有些问题就应该提出来思考了，为什么都是arm的指令集，苹果的芯片却可以吊打现在的Android厂商的芯片呢？评价CPU性能指标在以下几个方面：</p>
<p>一：指令集宽度（ISSUE）6</p>
<p>二：乱序指令执行缓冲区（Recorder Buffer）（192）</p>
<p>三：内存加载延迟（Load Latency）:4</p>
<p>四：分支预测错误代价（Misprediction Penalty）:16(一般介于14~19)</p>
<p>不得不说，<strong>苹果很早就开始布局CPU的设计之路，具有极强的芯片设计能力</strong>，在厂家都是基于arm的公版进行设计，苹果就已经通过购买arm指令集，然后进行自己的CPU设计，在14年的时候A7处理器，作为第一个ARM 64位CPU商用，而且将指令集宽度位6，作为对比arm目前的指令集为3；由于封闭式的开发，不像高通，需要考虑各个厂家的需求和成本，<strong>苹果有更高的溢价能力，可以用面积去换取性能与功耗，并根据自己的系统去做定制化</strong>；</p>
<h1><span id="指令集架构isa">指令集架构（ISA）</span></h1><p>CPU执行计算任务时都需要遵从一定的规范，程序在被执行时都需要先翻译成CPU可以理解的语言。这种规范就是指令集<strong>（ISA，Intruction Set Architecrure）;</strong></p>
<p>例如以下的机器码：1110 0001 1010 0000 0010 0000 0000 0001</p>
<p>比如有个CPU定位1110 0001就是ADD指令，1010 0000对应的是存储数据的寄存器R2；0010 0000对应的寄存器R0;<br>0000 0001对应是寄存器R1,故意思可以是ADD R2 R0 R1,将R0,R1的值加起来放到R2；指令集就是定义一套约定俗成的CPU运行规则，对于编程人员，面对的汇编指令；而对于CPU来说，就是怎么去理解这段二进制码，不同的CPU对这段二进制代码不同，故就有了不同的指令集架构； </p>
<p>指令集一般分为两种：<strong>精简指令集</strong>（RISC:reduced instruction set computer)和<strong>复杂指令集</strong>（CISC：Complex Instrution Set Computer）,以洗衣机洗衣服为例，RISC架构为，加水-&gt;漂洗-&gt;风干；而复杂指令集则可以发出洗衣服的指令，从而让洗衣机自动帮忙做这一整套的流程；CISC可以通过一条复杂的指令来完成许多事情，性能在处理复杂的任务时，会比RISC更为高效；但随之而来的是面积和功耗的提升；基于2/8理论，程序大部分时间（80%）都是在做重复而简单的事情；所以RISC架构就应运而生，更为精简的指令，将任务更多的放在了编译器这块，通过复杂的指令转化成简单指令的组合，在一定程度上增加了代码量，但使其大部分场合能比CISC取得更小的面积和功耗；</p>
<p>采用精简指令集的微处理，常见为ARM,MIPS，Power Architecture(包括PowerPC,PowerXCell),SPARC，RISC-V等而采用CISC则为X86和AMD</p>
<p>至于arm为代表RISC架构与以X86为代表的CISC之间的优劣比较还有是否存在替代一说，笔者认为，不会，而且从目前的发展来看，已经出现了你中有我，我中有你的局面；<br><a href="https://www.zhihu.com/question/20783321" target="_blank" rel="noopener">更进一步的探讨可以看下知乎上关于精简指令集与负杂指令集的讨论</a>,我也很赞同其中一个答主的观点，这已经不是个技术问题了，而是一个商业的问题</p>
<p>总结完RISC和CISC之间的关系，再讲讲基于RISC阵营里面的ARM和最近比较火热的RISC-V，arm大家都熟悉，而RISC-V又是个什么东西呢？</p>
<p>RISC-V是加州大学伯克利分校的开源指令集，由计算机架构的宗师级任务David Patterson领衔打造，通过将核心指令集以及<br>关键IP开源，意图改变半导体生态；详细的可以看这篇文档；<a href="http://www.semiinsights.com/s/electronic_components/23/30744.shtml" target="_blank" rel="noopener">名家专栏丨一文看懂RISC-V</a></p>
<p>总结如下：RISC-V具有以下优点：1.可模块化配置的指令集。 2.支持可扩展的指令集 3.一套指令集支持所有架构，基本指令集仅40余条指令，以此为共用基础，加上其他常用模块子集指令总指令集也仅几十条 4.硬件设计和编译器非常简单</p>
<p>笔者认为，RISC-V目前作为一个像linux看齐的硬件开源组织，linux之所以能健康长足发展，在于社区成千上万的内核爱好者的不断贡献，使得linux能够蓬勃发展；而硬件则不同，在这动辄上百万的流片费的无数摆在硬件设计者面前的坎，是否会有公司或者团体愿意将自己用血与泪验证的IP，贡献到社区，如果没有做到这一点，即将面临由于厂家扩展指令不同的碎片化问题解决，还有RISC-V后面的长足发展，将付之空谈；这样RISC-V架构只能作为几个大厂找到的低廉的替代arm方案的选择，而无法真正做到普惠；</p>
<h1><span id="arm的体系架构">arm的体系架构</span></h1><table>
<thead>
<tr>
<th>时间</th>
<th>架构</th>
<th>主要更新</th>
</tr>
</thead>
<tbody>
<tr>
<td>1985</td>
<td>ARMv1</td>
<td>只有26位的寻值空间，没有用于商业产品</td>
</tr>
<tr>
<td>1986</td>
<td>ARMv2</td>
<td>首颗量产的ARM处理器，包括32位乘法指令和协处理器指令</td>
</tr>
<tr>
<td>1990</td>
<td>ARMv3</td>
<td>具有片上高速缓存，MMU和写缓冲，寻址空间增大到32位</td>
</tr>
<tr>
<td>1993</td>
<td>ARMv4</td>
<td>ARM7，ARM8，ARM9和Strong ARM采用这种架构。增加了16 Thumb指令集</td>
</tr>
<tr>
<td>1998</td>
<td>ARMv5</td>
<td>ARM7(EJ),ARM9(E),ARM10(E)和Xscale采用这种了该架构，改进了ARM/Thumb状态之间的切换效率，此外还引入DSP指令和支持JAVA</td>
</tr>
<tr>
<td>2001</td>
<td>ARMv6</td>
<td>ARM11,强化了图形处理性能，通过追加有效进行多媒体处理的SIMD将语音及图像的处理功能大大提高。此外ARM在这个系列中引入混合16位/32位的Thumb-2指令集</td>
</tr>
<tr>
<td>2004</td>
<td>ARMv7</td>
<td>Cortex-M3/4/7,Cortex-R4/5/6/7,Cortex-A8/9都是基于该架构，该架构包括NEON技术扩展，可将DSP和媒体处理吞吐量高达400%，并提供改进的浮点支持以满足下一代3D图形和游戏以及传统嵌入式控制应用的需要</td>
</tr>
<tr>
<td>2007</td>
<td>ARMv6-M</td>
<td>专门为低成本，高性能的设备而设计，Cortex-M0/1即采用该架构</td>
</tr>
<tr>
<td>2011</td>
<td>ARMv8</td>
<td>Cortex-A32/35/53/57/72/73采用此架构，第一款支持64位的处理器架构</td>
</tr>
</tbody>
</table>
<h2><span id="arm架构发展图">ARM架构发展图：</span></h2><p><img src="/2018/11/17/cpu/arm体系架构的发展/arm_develop.png" alt="Arm架构发展"></p>
<h2><span id="arm体系的cpu工作模式">arm体系的CPU工作模式：</span></h2><p>1.用户模式(usr):正常的程序执行状态<br>2.快速中断模式（fiq）:用于支持高速数据传输或者通道处理<br>3.中断模式（irq）:用于普通中断处理<br>4.管理模式（svc）:操作系统使用的保护模式<br>5.系统模式（sys）:运行具有特权的操作系统的任务；<br>6.数据访问终止模式（abt）:数据或指令与预取终止时进入该模式<br>7.未定义指令终止模式（und）:未定义的指令执行时进入该模式；</p>
<p>linux如何从用户态进入内核态<br>分为两种：主动式和被动式、</p>
<p>1.主动式：就是linux用户在（ARM在用户模式下）工作，通过发起用户态程序发起命令请求，ARM响应进入特权模式进而Linux切入内核态，就是系统调用；系统调用可被堪称一个内核与用户空间程序交互的接口；把用户进程的请求传达 给内核，待内核把请求处理完毕后再将处理结果送回给用户空间；<br>系统调用的主要用途：</p>
<p>一：控制硬件-系统调用往往作为硬件资源和用户空间的抽象接口，比如读写文件用到的write/read调用</p>
<p>二：设置系统状态或读取内核数据；</p>
<p>2.被动式：就是Linux在用户态（ARM在用户模式）工作，没有主动发起请求，而被动地进入内核态，包括硬件中断和程序异常；</p>
<p>参考资料：</p>
<p><a href="http://www.10tiao.com/html/523/201708/2458284920/1.html" target="_blank" rel="noopener">arm汇编基础教程</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/36372153" target="_blank" rel="noopener">给开源架构泼泼冷水</a></p>
<p><a href="https://www.techbang.com/posts/10678-fully-understand-arm-processors-cisc-and-risc-are-what-history-structure-a-see-through-the-computer-96-issues-cover-story-the-king?comment_page=2&amp;page=1" target="_blank" rel="noopener">完全看懂ARM处理器:RISC与CISC是什么？历史，架构一次性看透</a></p>
<p><a href="http://www.wowotech.net/armv8a_arch/armv8-a_overview.html" target="_blank" rel="noopener">ARMv8-a</a></p>
<p><a href="https://www.veryarm.com/1164.html" target="_blank" rel="noopener">ARM介绍1：发展史</a><br><a href="https://www.veryarm.com/1170.html" target="_blank" rel="noopener">ARM介绍2：授权模式</a></p>
<p><a href="http://wiki.csie.ncku.edu.tw/embedded/ARMv8" target="_blank" rel="noopener">ARMV8</a></p>
<p><a href="https://www.ednchina.com/news/20170421apple.html" target="_blank" rel="noopener">从arm到三星，苹果是如何走向自研芯片的</a></p>
<p><a href="http://technews.tw/2017/12/13/why-apple-soc-so-dope/" target="_blank" rel="noopener">一样是ARM架构，为何苹果处理器效能就是压下其他人</a><br><a href="https://www.cnblogs.com/douzi2/p/5112743.html" target="_blank" rel="noopener">浅析arm的异常，中断和arm工作模式的联系</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">dongka</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongka</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
